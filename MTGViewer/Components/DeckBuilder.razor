@using MTGViewer.Data
@using MTGViewer.Data.Concurrency
@using MTGViewer.Data.Internal

@namespace MTGViewer.Components
@implements IAsyncDisposable

@inject IDbContextFactory<CardDbContext> DbFactory
@inject ILogger<DeckBuilder> Logger


<h1>@_deck.Name Builder</h1>

<button title="Save Deck"
        type="button"
        class="btn btn-secondary mb-3"
        disabled="@HasNoChanges()"
        @onclick="CommitChangesAsync">
    Save Changes
</button>

<SavePrompt @bind-Result="_result">
    <SuccessMessage>
        Save was succesful, and values have been updated
    </SuccessMessage>
    <ErrorMessage>
        <p>There are conflicts while trying to save, and values have been updated. </p>
        <hr>
        <p>Save again to confirm</p>
    </ErrorMessage>
</SavePrompt>


<h2>Available Cards</h2>

<table class="table">
    <thead>
        <tr>
            <th>Card Name</th>
            <th>Mana Cost</th>
            <th>Set</th>
            <th>Rarity</th>
            <th></th>
        </tr>
    </thead>

    <tbody>
        @foreach (var card in SortedCards)
        {
            <tr>
                <td class="fw-bold">@card.Name</td>

                <td>
                    @foreach (var cost in card.GetManaSymbols())
                    {
                        <span class="m-1 ms ms-@cost ms-cost"></span>
                    }
                </td>

                <td>@card.SetName</td>
                <td>@card.Rarity</td>
                <td>
                    <button title="Add @card.Name"
                            type="button"
                            class="btn btn-outline-secondary border-0 rounded"
                            @onclick="() => AddCardToDeck(card)">
                        Add Card
                    </button>
                </td>
            </tr>
        }
    </tbody>
</table>


<input @bind="_deck.Name" class="form-control form-control-lg border-0"/>

<table class="table mt-2">
    <thead>
        <tr>
            <th>Card Name</th>
            <th>Mana Cost</th>
            <th>Set</th>
            <th>Deck Amount</th>
            <th>Requests</th>
            <th></th>
        </tr>
    </thead>

    <tbody>
        @foreach (var card in DeckCards)
        {
            var group = _deckCards[card.Id];
            <tr>
                <td class="fw-bold">@card.Name</td>

                <td>
                    @foreach (var cost in card.GetManaSymbols())
                    {
                        <span class="m-1 ms ms-@cost ms-cost"></span>
                    }
                </td>

                <td>@card.SetName</td>

                <td>@((group.Actual?.Amount ?? 0) - (group.Return?.Amount ?? 0))</td>
                <td>@(group.Take?.Amount ?? 0)</td>

                <td>
                    <button title="Remove @card.Name"
                            type="button"
                            class="btn btn-outline-secondary border-0 rounded"
                            @onclick="() => RemoveCardFromDeck(card)">
                        Remove Card
                    </button>
                </td>
            </tr>
        }
    </tbody>
</table>


@code {

    [Parameter]
    public string UserId { get; set; }

    [Parameter]
    public int DeckId { get; set; } = default;


    private bool _busy;
    private SaveResult _result;
    private CardDbContext _dbContext;

    private UserRef _user;
    private Deck _deck;
    private SortedList<string, List<Card>> _dbCards;
    private IDictionary<string, RequestGroup> _deckCards;


    private bool HasNoChanges() =>
        !_dbContext.ChangeTracker.HasChanges();


    private IEnumerable<Card> SortedCards => 
        _dbCards.Values.SelectMany(cg => cg);

    private IEnumerable<Card> DeckCards =>
        SortedCards
            .Where(c => _deckCards.TryGetValue(c.Id, out var cardGroup)
                && cardGroup.Amount > 0);



    protected override async Task OnInitializedAsync()
    {
        if (_busy)
        {
            return;
        }

        _busy = true;
        try
        {
            _dbContext = DbFactory.CreateDbContext();

            var cards = await _dbContext.Cards.ToListAsync();

            var nameGroups = cards
                .GroupBy(c => c.Name)
                .ToDictionary(g => g.Key, g => g.ToList());

            _dbCards = new(nameGroups);

            @* var shares = await _dbContext.BoxAmounts
                // .Where(ca => ca.Location is Box)
                // TODO: change return location
                .ToListAsync();

            _availables = shares
                .GroupBy(ca => ca.CardId,
                    (_, amounts) => new CardGroup(amounts))
                .ToDictionary(cg => cg.CardId); *@
        }
        finally
        {
            _busy = false;
        }

        await base.OnInitializedAsync();
    }


    protected override async Task OnParametersSetAsync()
    {
        if (_busy)
        {
            return;
        }

        _busy = true;
        try
        {
            _user = await _dbContext.Users.FindAsync(UserId);

            _deck = await GetOrCreateDeckAsync();

            _deckCards = _deck.Cards
                .GroupBy(ca => ca.CardId)
                .ToDictionary(g => g.Key, InitGroup);
        }
        finally
        {
            _busy = false;
        }

        await base.OnParametersSetAsync();
    }


    private async Task<Deck> GetOrCreateDeckAsync()
    {
        if (DeckId != default)
        {
            return await _dbContext.Decks
                .Include(d => d.Cards)
                .SingleAsync(d => d.Id == DeckId);
        }

        var userDeckCount = await _dbContext.Decks
            .Where(l => l.Owner.Id == _user.Id)
            .CountAsync();

        var newLoc = new Deck($"Deck #{userDeckCount + 1}")
        {
            Owner = _user
        };

        _dbContext.Decks.Attach(newLoc);

        return newLoc;
    }


    private RequestGroup InitGroup(IEnumerable<DeckAmount> amounts)
    {
        var pair = new RequestGroup(amounts);

        if (pair.Actual is null)
        {
            var actual = new DeckAmount
            {
                Card = pair.Card,
                Location = pair.Location,
                Amount = 0
            };

            _dbContext.Amounts.Add(actual);
            pair.Actual = actual;
        }

        return pair;
    }


    public async ValueTask DisposeAsync()
    {
        if (_dbContext is not null)
        {
            await _dbContext.DisposeAsync();
        }
    }


    private void AddCardToDeck(Card card)
    {
        _result = SaveResult.None;

        bool hasGroup = _deckCards.TryGetValue(card.Id, out var deckGroup);

        if (hasGroup && deckGroup.Return?.Amount > 0)
        {
            deckGroup.Return.Amount -= 1;
            return;
        }

        if (!hasGroup || deckGroup.Take is null)
        {
            var takeAmount = new DeckAmount
            {
                Card = card,
                Location = _deck,
                Intent = Intent.Take,
                Amount = 0,
            };

            _dbContext.Amounts.Add(takeAmount);

            if (hasGroup)
            {
                deckGroup.Take = takeAmount;
            }
            else
            {
                deckGroup = new(takeAmount);
                _deckCards.Add(card.Id, deckGroup);
            }
        }

        deckGroup.Take.Amount += 1;
    }


    private void RemoveCardFromDeck(Card card)
    {
        _result = SaveResult.None;

        if (!_deckCards.TryGetValue(card.Id, out var deckGroup))
        {
            Logger.LogError($"card {card.Id} is not in the deck");
            return;
        }

        if (deckGroup.Take?.Amount > 0)
        {
            deckGroup.Take.Amount -= 1;
            return;
        }

        var actualRemain = deckGroup.Actual?.Amount ?? 0 - deckGroup.Return?.Amount ?? 0;

        if (actualRemain == 0)
        {
            Logger.LogError($"there are no more of {card.Id} to remove");
            return;
        }

        if (deckGroup.Return is null)
        {
            var returnAmount = new DeckAmount
            {
                Card = deckGroup.Card,
                Location = _deck,
                Intent = Intent.Return,
                Amount = 0
            };

            deckGroup.Return = returnAmount;
            _dbContext.Amounts.Attach(returnAmount);
        }

        deckGroup.Return.Amount += 1;
    }



    @* private void FixOverdraft(Card card)
    {
        if (!_deckCards.TryGetValue(card.Id, out var deckGroup))
        {
            Logger.LogInformation($"{card.Id} does not exist in deck");
            return;
        }

        if (availAmnt.Amount < 0)
        {
            if (deckGroup.Request is null)
            {
                deckGroup.Request = new DeckAmount
                {
                    Card = deckGroup.Card,
                    Location = deckGroup.Location,
                    Request = Request.Insert
                };

                _dbContext.Add(deckGroup.Request);
            }

            // transfer overdraft to request
            deckGroup.Actual.Amount += availAmnt.Amount;
            deckGroup.Request.Amount -= availAmnt.Amount;
            availAmnt.Amount = 0;
        }

        else if (availAmnt.Amount > 0 && deckGroup.Request?.Amount > 0)
        {
            int changeAmnt = Math.Min(availAmnt.Amount, deckGroup.Request.Amount);

            deckGroup.Actual.Amount += changeAmnt;
            deckGroup.Request.Amount -= changeAmnt;
            availAmnt.Amount -= changeAmnt;
        }
    } *@


    private async Task CommitChangesAsync()
    {
        if (_busy)
        {
            return;
        }

        _busy = true;

        PrepareChanges();

        try
        {
            await _dbContext.SaveChangesAsync();
            _result = SaveResult.Success;

            Logger.LogInformation($"successfully updated");
        }
        catch (DbUpdateConcurrencyException ex)
        {
            _result = SaveResult.Error;
            await UpdateDeckAsync(ex);
        }
        finally
        {
            _busy = false;
        }
    }


    private void PrepareChanges()
    {
        foreach (var cardAmnt in _deckCards.Values.SelectMany(g => g))
        {
            // detaches when saved after a remove
            if (_dbContext.Entry(cardAmnt).State == EntityState.Detached)
            {
                _dbContext.Amounts.Add(cardAmnt);
            }

            if (cardAmnt.Amount == 0)
            {
                _dbContext.Remove(cardAmnt);
            }
            
        }

        var deckEntry = _dbContext.Entry(_deck);

        if (deckEntry.State == EntityState.Unchanged)
        {
            deckEntry.State = EntityState.Modified;
        }
    }


    private async Task UpdateDeckAsync(DbUpdateConcurrencyException ex)
    {
        if (HasNoDeckConflicts(ex))
        {
            return;
        }

        var dbDeckCards = await _dbContext.Amounts
            .Where(ca => ca.LocationId == _deck.Id)
            .AsNoTracking()
            .ToListAsync();

        MergeDeckRemoves(dbDeckCards);

        foreach (var dbCard in dbDeckCards)
        {
            MergeDeckCardConflict(dbCard);
        }

        foreach(var cardGroup in dbDeckCards.GroupBy(ca => ca.CardId))
        {
            await TrackNewCardAsync(cardGroup);
        }

        CapDeletes();

        var dbDeck = await _dbContext.Entry(_deck).GetDatabaseValuesAsync();

        if (dbDeck == null)
        {
            _dbContext.Decks.Add(_deck);
        }
        else
        {
            _dbContext.MatchToken(_deck, dbDeck);
        }
    }


    private bool HasNoDeckConflicts(DbUpdateConcurrencyException ex)
    {
        var deckConflict = ex.Entries<Location>()
            .SingleOrDefault();

        if (deckConflict is not null && deckConflict.Entity.Id == _deck.Id)
        {
            return false;
        }

        var conflictsInDeck = ex.Entries<CardAmount>()
            .Select(ca => ca.Entity.CardId)
            .Intersect(_deckCards.Keys);

        return !conflictsInDeck.Any();
    }


    private void MergeDeckRemoves(IEnumerable<CardAmount> dbDeckCards)
    {
        var dbCardIds = dbDeckCards
            .Select(ca => ca.CardId)
            .Distinct();

        var removedCards = _deckCards.Keys
            .Except(dbCardIds)
            .SelectMany(id => _deckCards[id]);

        foreach(var removedCard in removedCards)
        {
            if (_dbContext.Entry(removedCard).State == EntityState.Unchanged)
            {
                _dbContext.Remove(removedCard);
            }
        }
    }


    private void MergeDeckCardConflict(DeckAmount dbDeckCard)
    {
        if (!_deckCards.TryGetValue(dbDeckCard.CardId, out var localDeckGroup))
        {
            return;
        }

        var localDeckCard = dbDeckCard.Intent switch
        {
            Intent.None => localDeckGroup.Actual,
            Intent.Take => localDeckGroup.Take,
            Intent.Return => localDeckGroup.Return,
            _ => null
        };

        if (localDeckCard is not null)
        {
            // keep local by default
            _dbContext.MatchToken(localDeckCard, dbDeckCard);

            if (_dbContext.Entry(localDeckCard).State == EntityState.Unchanged)
            {
                localDeckCard.Amount = dbDeckCard.Amount;
            }

            return;
        }

        switch (dbDeckCard.Intent)
        {
            case Intent.None:
                localDeckGroup.Actual = dbDeckCard;
                break;

            case Intent.Take:
                localDeckGroup.Take = dbDeckCard;
                break;

            case Intent.Return:
                localDeckGroup.Return = dbDeckCard;
                break;
        }

        // token also is matched
        _dbContext.Amounts.Attach(dbDeckCard);
    }


    private async Task TrackNewCardAsync(IGrouping<string, DeckAmount> cardGroup)
    {
        var cardId = cardGroup.Key;

        if (_deckCards.ContainsKey(cardId))
        {
            return;
        }

        // card now tracked by context
        var card = await _dbContext.Cards.FindAsync(cardId);
        var amntGroup = InitGroup(cardGroup);

        if (_dbContext.Entry(amntGroup.Actual).State == EntityState.Detached)
        {
            _dbContext.Amounts.Attach(amntGroup.Actual);
        }

        if (amntGroup.Take is not null
            && _dbContext.Entry(amntGroup.Take).State == EntityState.Detached)
        {
            _dbContext.Amounts.Attach(amntGroup.Take);
        }

        if (amntGroup.Return is not null
            && _dbContext.Entry(amntGroup.Return).State == EntityState.Detached)
        {
            _dbContext.Amounts.Attach(amntGroup.Return);
        }

        _deckCards.Add(cardId, amntGroup);
    }


    private void CapDeletes()
    {
        foreach(var cardGroup in _deckCards.Values)
        {
            if (cardGroup.Return is not null)
            {
                var currentDelete = cardGroup.Return.Amount;
                var capAmount = cardGroup.Actual?.Amount ?? currentDelete;

                cardGroup.Return.Amount = Math.Min(currentDelete, capAmount);
            }
        }
    }



    @* private async Task UpdateAvailableAsync()
    {
        var updatedAvails = await _dbContext.BoxAmounts
            // .Where(ca => ca.Location is Box)
            // TODO: change return location
            // TODO: group amounts by cards
            // .GroupBy(ca => ca.CardId)
            .AsNoTracking()
            .ToListAsync();

        var flatAvailables = _availables.Values
            .SelectMany(cg => cg)
            .ToDictionary(ca => (ca.CardId, ca.LocationId));

        foreach(var dbAvailable in updatedAvails)
        {
            var localKey = (dbAvailable.CardId, dbAvailable.LocationId);

            if (flatAvailables.TryGetValue(localKey, out var localAvailable))
            {
                MergeAvailable(localAvailable, dbAvailable);
            }
            else
            {
                await AddNewAvailableAsync(dbAvailable);

                flatAvailables.Add(localKey, dbAvailable);
            }
        }
    }


    private void MergeAvailable(CardAmount localAvailable, CardAmount dbAvailable)
    {
        var localAmnt = _dbContext.Entry(localAvailable).Property(ca => ca.Amount);
        var localAvailTaken = localAmnt.CurrentValue - localAmnt.OriginalValue;

        localAvailable.Amount = dbAvailable.Amount + localAvailTaken;

        _dbContext.MatchToken(localAvailable, dbAvailable);
    }


    private async Task AddNewAvailableAsync(CardAmount dbAvailable)
    {
        await _dbContext.Attach(dbAvailable)
            .Reference(ca => ca.Card)
            .LoadAsync();

        var availCard = dbAvailable.Card;

        if (_dbCards.TryGetValue(availCard.Name, out var nameGroup))
        {
            nameGroup.Add(availCard);
        }
        else
        {
            _dbCards.Add(availCard.Name, new(){ availCard });
        }


        if (_availables.TryGetValue(availCard.Id, out var localGroup))
        {
            localGroup.Add(dbAvailable);
        }
        else
        {
            _availables.Add(availCard.Id, new(dbAvailable));
        }
    } *@
}