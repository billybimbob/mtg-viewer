@using System.Linq.Expressions
@using MTGViewer.Data.Concurrency
@using MTGViewer.Data.Internal

@namespace MTGViewer.Components
@implements IAsyncDisposable

@inject IDbContextFactory<CardDbContext> DbFactory
@inject SymbolFormatter MtgSymbols
@inject CardText CardText

@inject NavigationManager Nav
@inject ILogger<DeckBuilder> Logger


<h1>@_deck?.Name Builder</h1>

<div class="mb-3">
    <button title="Save Deck" type="button"
        class="btn btn-secondary" 
        disabled="@HasNoChanges"
        @onclick="CommitChangesAsync">
        Save Changes
    </button>
</div>

<div class="form-row align-items-center my-3">
    <div class="col-3">
        <input class="form-control" placeholder="Card Name" @onchange="SearchName" />
    </div>

    <div class="col-auto btn-group" role="group" aria-label="Color Buttons">
        @foreach (var (symbol, color) in Color.Symbols)
        {
            var active = _colorFilter.Contains(color) ? "active" : "";

            <button title="@color filter" type="button"
                class="btn btn-outline-secondary border-0 rounded @active"
                @onclick="() => FilterColor(color)">

                <i class="ms ms-@symbol.ToLower() ms-cost"></i>
            </button>
        }
    </div>
</div>

<SavePrompt @bind-Result="_result">
    <SuccessMessage>
        Save was succesful, and values have been updated
    </SuccessMessage>
    <ErrorMessage>
        <p>There are conflicts while trying to save, and values have been updated. </p>
        <hr />
        <p>Save again to confirm</p>
    </ErrorMessage>
</SavePrompt>

<div class="row">
    <div class="col-7">
        <h3>Treasury</h3>

        <div class="list-group list-group-flush mb-4">
            @foreach (var (card, available) in Treasury)
            {
                var wantTotal = card.Wants.Sum(w => w.NumCopies);
                var previewId = $"{card.Id}-preview";

                <button type="button" title="Add @card.Name"
                    aria-controls="@previewId"
                    class="list-group-item list-group-item-action"
                    @onclick="() => AddCardToDeck(card)">

                    <span class="row">
                        <span class="col-6"> 
                            <HoverCard Card="card"> 
                                <span class="btn-link">@card.Name</span>
                            </HoverCard>
                        </span>

                        <span class="col-4"> @(MtgSymbols.Format(card.ManaCost).ToMarkupString()) </span>
                        <span class="col-2"> @(available - Math.Min(wantTotal, available)) </span>
                    </span>
                </button>
            }
        </div>

        <Pagination Pages="Pages" PageSelected="ApplyFilters" />
    </div>

    <div class="col">
        <div id="deck-builder">
            <EditForm EditContext="@_deckEdit">
                <DataAnnotationsValidator />
                <ValidationSummary />

                <InputText @bind-Value="_deck!.Name"/>
            </EditForm>

            <div id="deck-builder-cards" class="list-group list-group-flush">
                @foreach (var (card, group) in DeckCards)
                {
                    <button type="button" title="Remove @card.Name"
                        class="list-group-item list-group-item-action"
                        disabled="@(group.NumCopies <= 0)"
                        @onclick="() => RemoveCardFromDeck(card)">

                        <span class="row">
                            <span class="col-5">
                                <HoverCard Card="@card"> 
                                    <span class="btn-link">@card.Name</span>
                                </HoverCard>
                            </span>
                            <span class="col-4"> @(MtgSymbols.Format(card.ManaCost).ToMarkupString()) </span>

                            <span class="col-3">
                                <span title="@card.Name Held" class="badge badge-pill badge-primary"> 
                                    @(group.Amount?.NumCopies ?? 0) </span>

                                <span title="@card.Name Returning" class="badge badge-pill badge-danger"> 
                                    @(group.GiveBack?.NumCopies ?? 0) </span>

                                <span title="@card.Name Wanted" class="badge badge-pill badge-secondary">
                                    @(group.Want?.NumCopies ?? 0) </span>
                            </span>
                        </span>
                    </button>
                }
            </div>
        </div>
    </div>
</div>


@code {

    [Parameter]
    public string UserId { get; set; } = string.Empty;

    [Parameter]
    public int DeckId { get; set; } = default;

    [Parameter]
    public int PageSize { get; set; }


    private bool _isBusy;
    private readonly CancellationTokenSource _cancel = new();

    private SaveResult _result;
    private CardDbContext? _dbContext;

    private IReadOnlyList<Card> _cards = Array.Empty<Card>();
    private IReadOnlyDictionary<string, int>? _boxAmounts;

    private PagedList<Card> _filteredCards = PagedList<Card>.Empty;
    private readonly HashSet<string> _colorFilter = new(StringComparer.CurrentCultureIgnoreCase);
    private string? _searchName;

    private Deck? _deck;
    private EditContext? _deckEdit;
    private Dictionary<string, QuantityGroup>? _deckCards;



    private bool HasNoChanges =>
        !_dbContext?.ChangeTracker.HasChanges() ?? true;


    private IEnumerable<(Card, int amount)> Treasury =>
        _filteredCards
            .Select(c => (c, _boxAmounts?.GetValueOrDefault(c.Id) ?? 0));

    private Data.Pages Pages => _filteredCards.Pages;

    private IEnumerable<(Card, QuantityGroup)> DeckCards =>
        _deckCards is not null
            ? _cards
                .Where(c => _deckCards.TryGetValue(c.Id, out var cardGroup) && cardGroup.Total > 0)
                .Select(c => (c, _deckCards[c.Id]))

            : Enumerable.Empty<(Card, QuantityGroup)>();


    private IQueryable<Deck> DeckForBuilder(CardDbContext dbContext) =>
        dbContext.Decks
            .Where(d => d.Id == DeckId)
            .Include(d => d.Cards) // unbounded: keep eye on
            .Include(d => d.Wants) // unbounded: keep eye on
            .Include(d => d.GiveBacks) // unbounded: keep eye on
            .AsSplitQuery();



    protected override async Task OnInitializedAsync()
    {
        if (_isBusy)
        {
            return;
        }

        _isBusy = true;

        try
        {
            _dbContext = DbFactory.CreateDbContext();

            _cards = await _dbContext.Cards
                .Include(c => c.Colors)
                .OrderBy(c => c.Name)
                    .ThenBy(c => c.SetName)
                .ToListAsync(_cancel.Token); // unbounded, keep eye on

            _boxAmounts = await _dbContext.Amounts
                .Where(ca => ca.Location is Box)
                .GroupBy(ca => ca.CardId,
                    (CardId, cas) => 
                        new { CardId, Total = cas.Sum(ca => ca.NumCopies) })
                .ToDictionaryAsync(
                    ct => ct.CardId, ct => ct.Total, _cancel.Token);
        }
        catch (OperationCanceledException ex)
        {
            Logger.LogError(ex.ToString());
        }
        finally
        {
            _isBusy = false;
        }
    }


    protected override async Task OnParametersSetAsync()
    {
        if (_isBusy)
        {
            return;
        }

        _isBusy = true;

        try
        {
            _deck = await GetOrCreateDeckAsync();

            _deckEdit = new(_deck);

            _deckCards = GetDeckCardGroups(_deck)
                .ToDictionary(cg => cg.CardId);

            ApplyFilters();
        }

        catch (DbUpdateException ex)
        {
            Logger.LogError(ex.ToString());
        }
        catch (OperationCanceledException ex)
        {
            Logger.LogError(ex.ToString());
        }
        finally
        {
            _isBusy = false;
        }
    }


    private async Task<Deck> GetOrCreateDeckAsync()
    {
        if (_dbContext is null)
        {
            throw new NullReferenceException(nameof(_dbContext));
        }

        if (DeckId != default)
        {
            var deck = await DeckForBuilder(_dbContext)
                .SingleAsync(_cancel.Token);

            return deck;
        }

        var userValue = new []{ UserId };
        var user = await _dbContext.Users.FindAsync(userValue, _cancel.Token);

        if (user == null)
        {
            throw new ArgumentException(nameof(UserId));
        }

        var userDeckCount = await _dbContext.Decks
            .Where(d => d.OwnerId == UserId)
            .CountAsync(_cancel.Token);

        var newLoc = new Deck
        {
            Name = $"Deck #{userDeckCount + 1}",
            Owner = user
        };

        _dbContext.Decks.Attach(newLoc);

        return newLoc;
    }


    private IEnumerable<QuantityGroup> GetDeckCardGroups(Deck deck)
    {
        var amountsById = deck.Cards.ToDictionary(ca => ca.CardId);
        var takesById = deck.Wants.ToDictionary(w => w.CardId);
        var givesById = deck.GiveBacks.ToDictionary(g => g.CardId);

        var cardIds = amountsById.Keys
            .Union(takesById.Keys)
            .Union(givesById.Keys);

        return cardIds.Select(cid =>
            new QuantityGroup(
                amountsById.GetValueOrDefault(cid),
                takesById.GetValueOrDefault(cid),
                givesById.GetValueOrDefault(cid) ));
    }


    public async ValueTask DisposeAsync()
    {
        _cancel.Cancel();
        _cancel.Dispose();

        if (_dbContext is not null)
        {
            await _dbContext.DisposeAsync();
        }
    }


    private void FilterColor(string color)
    {
        if (_colorFilter.Contains(color))
        {
            _colorFilter.Remove(color);
        }
        else
        {
            _colorFilter.Add(color);
        }

        ApplyFilters();
    }


    private void SearchName(ChangeEventArgs eventArgs)
    {
        _searchName = eventArgs.Value?.ToString();
        
        ApplyFilters();
    }


    private void ApplyFilters(int pageIndex = 0)
    {
        const StringComparison ignoreCase = StringComparison.CurrentCultureIgnoreCase;

        var filter = _cards.AsEnumerable();

        if (!string.IsNullOrWhiteSpace(_searchName))
        {
            filter = filter
                .Where(c => c.Name
                    .Contains(_searchName, ignoreCase));
        }

        if (_colorFilter.Any())
        {
            filter = filter
                .Where(c => c.Colors
                    .Any(cl => _colorFilter.Contains(cl.Name) ));
        }

        _filteredCards = filter.ToPagedList(PageSize, pageIndex);
    }


    private void AddCardToDeck(Card card)
    {
        if (_dbContext == null || _deck == null || _deckCards == null)
        {
            return;
        }

        _result = SaveResult.None;

        var deckGroup = _deckCards.GetValueOrDefault(card.Id);

        if (deckGroup?.GiveBack?.NumCopies > 0)
        {
            deckGroup.GiveBack.NumCopies -= 1;
            return;
        }

        if (deckGroup?.Want is null)
        {
            // todo: add want limit

            var wantAmount = new Want
            {
                Card = card,
                Location = _deck,
                NumCopies = 0,
            };

            _dbContext.Wants.Attach(wantAmount);

            if (deckGroup is null)
            {
                deckGroup = new(wantAmount);
                _deckCards.Add(card.Id, deckGroup);
            }
            else
            {
                deckGroup.Want = wantAmount;
            }
        }

        deckGroup.Want!.NumCopies += 1;
    }


    private void RemoveCardFromDeck(Card card)
    {
        if (_dbContext == null || _deck == null || _deckCards == null)
        {
            return;
        }

        _result = SaveResult.None;

        if (!_deckCards.TryGetValue(card.Id, out var deckGroup))
        {
            Logger.LogError($"card {card.Id} is not in the deck");
            return;
        }

        if (deckGroup.Want?.NumCopies > 0)
        {
            deckGroup.Want.NumCopies -= 1;
            return;
        }

        var actualRemain = (deckGroup.Amount?.NumCopies ?? 0)
            - (deckGroup.GiveBack?.NumCopies ?? 0);

        if (actualRemain == 0)
        {
            // Logger.LogError($"there are no more of {card.Id} to remove");
            return;
        }

        if (deckGroup.GiveBack is null)
        {
            var returnAmount = new GiveBack
            {
                Card = deckGroup.Card,
                Location = _deck,
                NumCopies = 0
            };

            _dbContext.GiveBacks.Attach(returnAmount);
            deckGroup.GiveBack = returnAmount;
        }

        deckGroup.GiveBack.NumCopies += 1;
    }



    private async Task CommitChangesAsync()
    {
        if (_dbContext == null || _deck == null || _deckCards == null)
        {
            return;
        }

        if (_isBusy)
        {
            return;
        }

        if (_deckEdit is null || !_deckEdit.Validate())
        {
            return;
        }

        _isBusy = true;

        try
        {
            PrepareChanges(_dbContext, _deck);

            await _dbContext.SaveChangesAsync(_cancel.Token);

            if (_deck.GiveBacks.Any() || _deck.Wants.Any())
            {
                Nav.NavigateTo($"/Decks/Exchange/{_deck.Id}", true);
            }
            else
            {
                _result = SaveResult.Success;
            }
        }
        catch (DbUpdateConcurrencyException ex)
        {
            _result = SaveResult.Error;

            await UpdateDeckAsync(_dbContext, _deck, _deckCards, ex, _cancel.Token);
        }
        catch (DbUpdateException ex)
        {
            Logger.LogError(ex.ToString());
        }
        catch (OperationCanceledException ex)
        {
            Logger.LogError(ex.ToString());
        }

        finally
        {
            _isBusy = false;
        }
    }


    private void PrepareChanges(CardDbContext dbContext, Deck deck)
    {
        foreach (var want in deck.Wants)
        {
            if (want.NumCopies == 0)
            {
                dbContext.Wants.Remove(want);
            }
            // detaches when saved after a remove
            else if (dbContext.Entry(want).State == EntityState.Detached)
            {
                dbContext.Wants.Add(want);
            }
        }

        foreach (var giveBack in deck.GiveBacks)
        {
            if (giveBack.NumCopies == 0)
            {
                dbContext.GiveBacks.Remove(giveBack);
            }
            else if (dbContext.Entry(giveBack).State == EntityState.Detached)
            {
                dbContext.GiveBacks.Add(giveBack);
            }
        }

        var deckEntry = dbContext.Entry(deck);

        if (deckEntry.State == EntityState.Unchanged)
        {
            deckEntry.State = EntityState.Modified;
        }

        deck.UpdateColors(CardText);
    }


    private async Task UpdateDeckAsync(
        CardDbContext dbContext,
        Deck localDeck,
        Dictionary<string, QuantityGroup> deckCards,
        DbUpdateConcurrencyException ex,
        CancellationToken cancel)
    {
        if (HasNoDeckConflicts(localDeck, deckCards.Keys, ex))
        {
            return;
        }

        if (cancel.IsCancellationRequested)
        {
            return;
        }

        Deck? dbDeck = default;

        try
        {
            dbDeck = await DeckForBuilder(dbContext)
                .AsNoTracking()
                .SingleOrDefaultAsync(cancel);
        }
        catch (OperationCanceledException)
        { }

        if (cancel.IsCancellationRequested)
        {
            return;
        }

        if (dbDeck == default)
        {
            dbContext.Decks.Add(localDeck);
            return;
        }

        MergeDeckRemoves(dbContext, localDeck, dbDeck);
        TrackNewDeckCards(dbContext, deckCards, dbDeck);
        MergeDeckCardConflicts(dbContext, deckCards, dbDeck);

        CapDeletes(deckCards.Values);
        dbContext.MatchToken(localDeck, dbDeck);
    }


    private static bool HasNoDeckConflicts(
        Deck deck, 
        IEnumerable<string> deckIds,
        DbUpdateConcurrencyException ex)
    {
        var deckConflict = ex.Entries<Location>().SingleOrDefault();

        if (deckConflict is not null && deckConflict.Entity.Id == deck.Id)
        {
            return false;
        }

        var conflictsInDeck = ex.Entries<Amount>()
            .Select(ca => ca.Entity.CardId)
            .Intersect(deckIds);

        return !conflictsInDeck.Any();
    }


    private static void MergeDeckRemoves(
        CardDbContext dbContext, Deck localDeck, Deck dbDeck)
    {
        var removedCards = RemovedFromDb(localDeck.Cards, dbDeck.Cards);

        foreach(var removedCard in removedCards)
        {
            removedCard.NumCopies = 0;
            dbContext.Amounts.Remove(removedCard);
        }

        var removedWants = RemovedFromDb(localDeck.Wants, dbDeck.Wants);

        foreach (var removedWant in removedWants)
        {
            if (dbContext.Entry(removedWant).State == EntityState.Unchanged)
            {
                removedWant.NumCopies = 0;
                dbContext.Wants.Remove(removedWant);
            }
            else
            {
                dbContext.Wants.Add(removedWant);
            }
        }

        var removedGiveBacks = RemovedFromDb(localDeck.GiveBacks, dbDeck.GiveBacks);

        foreach (var removedGive in removedGiveBacks)
        {
            if (dbContext.Entry(removedGive).State == EntityState.Unchanged)
            {
                removedGive.NumCopies = 0;
                dbContext.GiveBacks.Remove(removedGive);
            }
            else
            {
                dbContext.GiveBacks.Add(removedGive);
            }
        }
    }


    private static IEnumerable<TQuantity> RemovedFromDb<TQuantity>(
        IEnumerable<TQuantity> localQuantity, 
        IEnumerable<TQuantity> dbQuantity)
        where TQuantity : Quantity
    {
        return localQuantity
            .GroupJoin(dbQuantity,
                lq => (lq.CardId, lq.LocationId),
                db => (db.CardId, db.LocationId),
                (local, dbs) =>
                    (local, noDb: !dbs.Any()))
            .Where(ln => ln.noDb)
            .Select(ln => ln.local);
    }


    private void MergeDeckCardConflicts(
        CardDbContext dbContext,
        IReadOnlyDictionary<string, QuantityGroup> deckCards,
        Deck dbDeck)
    {
        MergeQuantityConflicts(dbContext, deckCards, dbDeck.Cards, group => group.Amount);

        MergeQuantityConflicts(dbContext, deckCards, dbDeck.Wants, group => group.Want);

        MergeQuantityConflicts(dbContext, deckCards, dbDeck.GiveBacks, group => group.GiveBack);
    }


    private void MergeQuantityConflicts<TQuantity>(
        CardDbContext dbContext, 
        IReadOnlyDictionary<string, QuantityGroup> deckCards,
        IEnumerable<TQuantity> dbQuantities, 
        Func<QuantityGroup, TQuantity?> quantity)
        where TQuantity : Quantity
    {
        foreach (var dbQuantity in dbQuantities)
        {
            if (!deckCards.TryGetValue(dbQuantity.CardId, out var localGroup))
            {
                continue;
            }

            var localQuantity = quantity(localGroup);

            if (localQuantity is null)
            {
                continue;
            }

            if (dbContext.Entry(localQuantity).State == EntityState.Unchanged)
            {
                localQuantity.NumCopies = dbQuantity.NumCopies;
            }

            dbContext.MatchToken(localQuantity, dbQuantity);
        }
    }


    private void TrackNewDeckCards(
        CardDbContext dbContext, IDictionary<string, QuantityGroup> deckCards, Deck dbDeck)
    {
        TrackNewQuantity(dbContext, deckCards, dbDeck.Cards, group => group.Amount);

        TrackNewQuantity(dbContext, deckCards, dbDeck.Wants, group => group.Want);

        TrackNewQuantity(dbContext, deckCards, dbDeck.GiveBacks, group => group.GiveBack);
    }


    private void TrackNewQuantity<TQuantity>(
        CardDbContext dbContext, 
        IDictionary<string, QuantityGroup> deckCards,
        IEnumerable<TQuantity> dbQuantities,
        Expression<Func<QuantityGroup, TQuantity?>> quantity)
        where TQuantity : Quantity
    {
        var quantityName = (quantity as MemberExpression)?.Member.Name;
        
        if (quantityName is null)
        {
            return;
        }

        var localQuantity = typeof(QuantityGroup).GetProperty(quantityName);

        if (localQuantity is null)
        {
            return;
        }

        foreach (var dbQuantity in dbQuantities)
        {
            var hasGroup = deckCards.TryGetValue(dbQuantity.CardId, out var localGroup);

            if (hasGroup && localQuantity.GetValue(localGroup) is not null)
            {
                continue;
            }

            if (hasGroup)
            {
                localQuantity.SetValue(localGroup, dbQuantity);
            }
            else
            {
                localGroup = new(dbQuantity);
                deckCards.Add(dbQuantity.CardId, localGroup);
            }

            dbContext.Attach(dbQuantity);
        }
    }


    private void CapDeletes(IEnumerable<QuantityGroup> deckCards)
    {
        foreach(var cardGroup in deckCards)
        {
            if (cardGroup.GiveBack is null)
            {
                continue;
            }

            var currentReturn = cardGroup.GiveBack.NumCopies;
            var capAmount = cardGroup.Amount?.NumCopies ?? currentReturn;

            cardGroup.GiveBack.NumCopies = Math.Min(currentReturn, capAmount);
        }
    }
}