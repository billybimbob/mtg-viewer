@using MTGViewer.Data
@using MTGViewer.Data.Concurrency
@using MTGViewer.Data.Internal

@namespace MTGViewer.Components
@implements IAsyncDisposable

@inject IDbContextFactory<CardDbContext> DbFactory
@inject ILogger<DeckBuilder> Logger


<h1>@_deck.Name Builder</h1>

<div class="mb-3">
    <button title="Save Deck"
            type="button"
            class="btn btn-secondary"
            disabled="@HasNoChanges"
            @onclick="CommitChangesAsync">
        Save Changes
    </button>

    @if (_result is SaveResult.Success)
    {
        <a href="/Decks/Checkout/@_deck.Id"
            role="button"
            class="btn btn-secondary ml-2">
            Checkout </a>
    }
    else
    {
        <a href="/Decks/Checkout/@_deck.Id"
            role="button"
            class="btn btn-secondary ml-2 disabled"
            tabindex="-1"
            aria-disabled="true">
            Checkout </a>
    }
</div>

<SavePrompt @bind-Result="_result">
    <SuccessMessage>
        Save was succesful, and values have been updated
    </SuccessMessage>
    <ErrorMessage>
        <p>There are conflicts while trying to save, and values have been updated. </p>
        <hr>
        <p>Save again to confirm</p>
    </ErrorMessage>
</SavePrompt>


<EditForm EditContext="@_deckEdit">
    <DataAnnotationsValidator />
    <ValidationSummary />

    <InputText @bind-Value="_deck.Name" class="form-control form-control-lg border-0"/>
</EditForm>

<table class="table mt-2">
    <thead>
        <tr>
            <th>Card Name</th>
            <th>Mana Cost</th>
            <th>Set</th>
            <th>Deck Amount</th>
            <th>Requests</th>
            <th></th>
        </tr>
    </thead>

    <tbody>
        @foreach (var card in DeckCards)
        {
            var group = _deckCards[card.Id];
            <tr>
                <td class="fw-bold">@card.Name</td>

                <td>
                    @foreach (var cost in card.GetManaSymbols())
                    {
                        <span class="m-1 ms ms-@cost ms-cost"></span>
                    }
                </td>

                <td>@card.SetName</td>

                <td>@((group.Actual?.Amount ?? 0) - (group.GiveBack?.Amount ?? 0))</td>
                <td>@(group.Want?.Amount ?? 0)</td>

                <td>
                    <button title="Remove @card.Name"
                            type="button"
                            class="btn btn-outline-secondary border-0 rounded"
                            @onclick="() => RemoveCardFromDeck(card)">
                        Remove Card
                    </button>
                </td>
            </tr>
        }
    </tbody>
</table>


<h2>Available Cards</h2>

<table class="table">
    <thead>
        <tr>
            <th>Card Name</th>
            <th>Mana Cost</th>
            <th>Set</th>
            <th>Rarity</th>
            <th>Amount Shared</th>
            <th></th>
        </tr>
    </thead>

    <tbody>
        @foreach (var card in AllCards)
        {
            <tr>
                <td class="fw-bold">@card.Name</td>

                <td>
                    @foreach (var cost in card.GetManaSymbols())
                    {
                        <span class="m-1 ms ms-@cost ms-cost"></span>
                    }
                </td>

                <td>@card.SetName</td>
                <td>@card.Rarity</td>

                <td>
                    @(card.Amounts
                        .Where(ca => ca.Location is Box)
                        .Sum(ca => ca.Amount))
                </td>

                <td>
                    <button title="Add @card.Name"
                            type="button"
                            class="btn btn-outline-secondary border-0 rounded"
                            @onclick="() => AddCardToDeck(card)">
                        Add Card
                    </button>
                </td>
            </tr>
        }
    </tbody>
</table>


@code {

    [Parameter]
    public string UserId { get; set; }

    [Parameter]
    public int DeckId { get; set; } = default;


    private bool _busy;
    private SaveResult _result;
    private CardDbContext _dbContext;

    private Deck _deck;
    private EditContext _deckEdit;
    private IDictionary<string, AmountRequestGroup> _deckCards;



    private bool HasNoChanges =>
        !_dbContext.ChangeTracker.HasChanges();


    private IReadOnlyList<Card> AllCards { get; set; }


    private IEnumerable<Card> DeckCards =>
        AllCards.Where((Func<Card, bool>)(c => _deckCards != null
            && _deckCards.TryGetValue(c.Id, out var cardGroup)
            && cardGroup.Amount > 0));


    private IQueryable<Deck> DeckForBuilder =>
        _dbContext.Decks
            .Where(d => d.Id == DeckId)
            .Include(d => d.Owner)
            .Include(d => d.Cards) // unbounded: keep eye on
            .Include(d => d.Wants) // unbounded: keep eye on
            .Include(d => d.GiveBacks) // unbounded: keep eye on
            .AsSplitQuery();



    protected override async Task OnInitializedAsync()
    {
        if (_busy)
        {
            return;
        }

        _busy = true;
        try
        {
            _dbContext = DbFactory.CreateDbContext();

            AllCards = await _dbContext.Cards
                .Include(c => c.Amounts
                    .Where(ca => ca.Location is Box))
                    .ThenInclude(ca => ca.Location)
                .OrderBy(c => c.Name)
                    .ThenBy(c => c.SetName)
                .ToListAsync();
        }
        finally
        {
            _busy = false;
        }

        await base.OnInitializedAsync();
    }


    protected override async Task OnParametersSetAsync()
    {
        if (_busy)
        {
            return;
        }

        _busy = true;
        try
        {
            _deck = await GetOrCreateDeckAsync();
            _deckEdit = new(_deck);

            _deckCards = GetDeckCardGroups(_deck)
                .ToDictionary(cg => cg.CardId);
        }
        finally
        {
            _busy = false;
        }

        await base.OnParametersSetAsync();
    }


    private async Task<Deck> GetOrCreateDeckAsync()
    {
        if (DeckId != default)
        {
            return await DeckForBuilder.SingleAsync();
        }

        var user = await _dbContext.Users.FindAsync(UserId);

        var userDeckCount = await _dbContext.Decks
            .Where(d => d.Owner.Id == UserId)
            .CountAsync();

        var newLoc = new Deck
        {
            Name = $"Deck #{userDeckCount + 1}",
            Owner = user
        };

        _dbContext.Decks.Attach(newLoc);

        return newLoc;
    }


    private IEnumerable<AmountRequestGroup> GetDeckCardGroups(Deck deck)
    {
        var amountsById = deck.Cards
            .ToDictionary(ca => ca.CardId);

        var requestsById = deck.Wants
            .ToLookup(cr => cr.CardId);

        var cardIds = amountsById
            .Select(g => g.Key)
            .Union(requestsById
                .Select(g => g.Key));

        return cardIds.Select(cid =>
            new AmountRequestGroup(
                amountsById.GetValueOrDefault(cid), requestsById[cid]) );
    }


    public async ValueTask DisposeAsync()
    {
        if (_dbContext is not null)
        {
            await _dbContext.DisposeAsync();
        }
    }


    private void AddCardToDeck(Card card)
    {
        if (_deck == null || _deckCards == null)
        {
            return;
        }

        _result = SaveResult.None;

        bool hasGroup = _deckCards.TryGetValue(card.Id, out var deckGroup);

        if (hasGroup && deckGroup.GiveBack?.Amount > 0)
        {
            deckGroup.GiveBack.Amount -= 1;
            return;
        }

        if (!hasGroup || deckGroup.Want is null)
        {
            var wantAmount = new Want
            {
                Card = card,
                Target = _deck,
                Amount = 0,
            };

            _dbContext.Wants.Attach(wantAmount);

            if (hasGroup)
            {
                deckGroup.Want = wantAmount;
            }
            else
            {
                deckGroup = new(wantAmount);
                _deckCards.Add(card.Id, deckGroup);
            }
        }

        deckGroup.Want.Amount += 1;
    }


    private void RemoveCardFromDeck(Card card)
    {
        if (_deck == null || _deckCards == null)
        {
            return;
        }

        _result = SaveResult.None;

        if (!_deckCards.TryGetValue(card.Id, out var deckGroup))
        {
            Logger.LogError($"card {card.Id} is not in the deck");
            return;
        }

        if (deckGroup.Want?.Amount > 0)
        {
            deckGroup.Want.Amount -= 1;
            return;
        }

        var actualRemain = (deckGroup.Actual?.Amount ?? 0)
            - (deckGroup.GiveBack?.Amount ?? 0);

        if (actualRemain == 0)
        {
            Logger.LogError($"there are no more of {card.Id} to remove");
            return;
        }

        if (deckGroup.GiveBack is null)
        {
            var returnAmount = new GiveBack
            {
                Card = deckGroup.Card,
                Target = _deck,
                Amount = 0
            };

            _dbContext.GiveBacks.Attach(returnAmount);
            deckGroup.GiveBack = returnAmount;
        }

        deckGroup.GiveBack.Amount += 1;
    }



    private async Task CommitChangesAsync()
    {
        if (_deck == null || _deckCards == null)
        {
            return;
        }

        if (_busy)
        {
            return;
        }

        if (!_deckEdit.Validate())
        {
            return;
        }

        _busy = true;
        PrepareChanges();

        try
        {
            await _dbContext.SaveChangesAsync();
            _result = SaveResult.Success;

            Logger.LogInformation($"successfully updated");
        }
        catch (DbUpdateConcurrencyException ex)
        {
            _result = SaveResult.Error;
            await UpdateDeckAsync(ex);
        }
        finally
        {
            _busy = false;
        }
    }


    private void PrepareChanges()
    {
        foreach (var want in _deck.Wants)
        {
            if (want.Amount == 0)
            {
                _dbContext.Wants.Remove(want);
            }
            // detaches when saved after a remove
            else if (_dbContext.Entry(want).State == EntityState.Detached)
            {
                _dbContext.Wants.Add(want);
            }
        }

        foreach (var giveBack in _deck.GiveBacks)
        {
            if (giveBack.Amount == 0)
            {
                _dbContext.GiveBacks.Remove(giveBack);
            }
            else if (_dbContext.Entry(giveBack).State == EntityState.Detached)
            {
                _dbContext.GiveBacks.Add(giveBack);
            }
        }

        var deckEntry = _dbContext.Entry(_deck);

        if (deckEntry.State == EntityState.Unchanged)
        {
            deckEntry.State = EntityState.Modified;
        }

        _deck.UpdateColorSymbols();
    }


    private async Task UpdateDeckAsync(DbUpdateConcurrencyException ex)
    {
        if (HasNoDeckConflicts(ex))
        {
            return;
        }

        var dbDeck = await DeckForBuilder
            .AsNoTracking()
            .SingleOrDefaultAsync();

        if (dbDeck == default)
        {
            _dbContext.Decks.Add(_deck);
            return;
        }

        MergeDeckRemoves(dbDeck);
        TrackNewDeckCards(dbDeck);

        MergeDeckCardConflicts(dbDeck);
        CapDeletes();

        _dbContext.MatchToken(_deck, dbDeck);
    }


    private bool HasNoDeckConflicts(DbUpdateConcurrencyException ex)
    {
        var deckConflict = ex.Entries<Location>()
            .SingleOrDefault();

        if (deckConflict is not null && deckConflict.Entity.Id == _deck.Id)
        {
            return false;
        }

        var conflictsInDeck = ex.Entries<CardAmount>()
            .Select(ca => ca.Entity.CardId)
            .Intersect(_deckCards.Keys);

        return !conflictsInDeck.Any();
    }


    private void MergeDeckRemoves(Deck dbDeck)
    {
        var removedCards = _deck.Cards
            .GroupJoin( dbDeck.Cards,
                local => local.CardId, db => db.CardId,
                (local, dbs) =>
                    (local, noDb: !dbs.Any()))
            .Where(ln => ln.noDb)
            .Select(ln => ln.local);

        foreach(var removedCard in removedCards)
        {
            removedCard.Amount = 0;
            _dbContext.Amounts.Remove(removedCard);
        }


        var removedWants = _deck.Wants
            .GroupJoin( dbDeck.Wants,
                wt => (wt.CardId, wt.TargetId),
                db => (db.CardId, db.TargetId),
                (local, dbs) =>
                    (local, noDb: !dbs.Any()))
            .Where(ln => ln.noDb)
            .Select(ln => ln.local);

        foreach (var removedWant in removedWants)
        {
            if (_dbContext.Entry(removedWant).State == EntityState.Unchanged)
            {
                removedWant.Amount = 0;
                _dbContext.Wants.Remove(removedWant);
            }
            else
            {
                _dbContext.Wants.Add(removedWant);
            }
        }


        var removedGiveBacks = _deck.GiveBacks
            .GroupJoin( dbDeck.GiveBacks,
                gb => (gb.CardId, gb.TargetId),
                db => (db.CardId, db.TargetId),
                (local, dbs) =>
                    (local, noDb: !dbs.Any()))
            .Where(ln => ln.noDb)
            .Select(ln => ln.local);

        foreach (var removedGive in removedGiveBacks)
        {
            if (_dbContext.Entry(removedGive).State == EntityState.Unchanged)
            {
                removedGive.Amount = 0;
                _dbContext.GiveBacks.Remove(removedGive);
            }
            else
            {
                _dbContext.GiveBacks.Add(removedGive);
            }
        }
    }


    private void MergeDeckCardConflicts(Deck dbDeck)
    {
        foreach (var dbCard in dbDeck.Cards)
        {
            if (!_deckCards.TryGetValue(dbCard.CardId, out var localGroup)
                || localGroup.Actual is null)
            {
                continue;
            }

            var localCard = localGroup.Actual;

            if (_dbContext.Entry(localCard).State == EntityState.Unchanged)
            {
                localCard.Amount = dbCard.Amount;
            }

            _dbContext.MatchToken(localCard, dbCard);
        }


        foreach (var dbWant in dbDeck.Wants)
        {
            if (!_deckCards.TryGetValue(dbWant.CardId, out var localGroup)
                || localGroup.Want is null)
            {
                continue;
            }

            var localTake = localGroup.Want;

            if (_dbContext.Entry(localTake).State == EntityState.Unchanged)
            {
                localTake.Amount = dbWant.Amount;
            }

            _dbContext.MatchToken(localTake, dbWant);
        }


        foreach (var dbGiveBack in dbDeck.GiveBacks)
        {
            if (!_deckCards.TryGetValue(dbGiveBack.CardId, out var localGroup)
                || localGroup.GiveBack is null)
            {
                continue;
            }

            var localReturn = localGroup.GiveBack;

            if (_dbContext.Entry(localReturn).State == EntityState.Unchanged)
            {
                localReturn.Amount = dbGiveBack.Amount;
            }

            _dbContext.MatchToken(localReturn, dbGiveBack);
        }
    }


    private void TrackNewDeckCards(Deck dbDeck)
    {
        foreach (var dbCard in dbDeck.Cards)
        {
            var hasGroup = _deckCards.TryGetValue(dbCard.CardId, out var localGroup);

            if (hasGroup && localGroup.Actual is not null)
            {
                continue;
            }

            if (hasGroup)
            {
                localGroup.Actual = dbCard;
            }
            else
            {
                localGroup = new(dbCard);
                _deckCards.Add(dbCard.CardId, localGroup);
            }

            _dbContext.Amounts.Attach(dbCard);
        }


        foreach (var dbWant in dbDeck.Wants)
        {
            var hasGroup = _deckCards.TryGetValue(dbWant.CardId, out var localGroup);

            if (hasGroup && localGroup.Want is not null)
            {
                continue;
            }

            if (hasGroup)
            {
                localGroup.Want = dbWant;
            }
            else
            {
                localGroup = new(dbWant);
                _deckCards.Add(dbWant.CardId, localGroup);
            }

            _dbContext.Wants.Attach(dbWant);
        }


        foreach (var dbGiveBack in dbDeck.GiveBacks)
        {
            var hasGroup = _deckCards.TryGetValue(dbGiveBack.CardId, out var localGroup);

            if (hasGroup && localGroup.GiveBack is not null)
            {
                continue;
            }

            if (hasGroup)
            {
                localGroup.GiveBack = dbGiveBack;
            }
            else
            {
                localGroup = new(dbGiveBack);
                _deckCards.Add(dbGiveBack.CardId, localGroup);
            }

            _dbContext.GiveBacks.Attach(dbGiveBack);
        }
    }


    private void CapDeletes()
    {
        foreach(var cardGroup in _deckCards.Values)
        {
            if (cardGroup.GiveBack is null)
            {
                continue;
            }

            var currentReturn = cardGroup.GiveBack.Amount;
            var capAmount = cardGroup.Actual?.Amount ?? currentReturn;

            cardGroup.GiveBack.Amount = Math.Min(currentReturn, capAmount);
        }
    }
}