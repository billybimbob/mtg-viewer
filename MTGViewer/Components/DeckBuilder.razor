@using MTGViewer.Data.Concurrency
@using MTGViewer.Data.Internal

@namespace MTGViewer.Components
@implements IAsyncDisposable

@inject IDbContextFactory<CardDbContext> DbFactory
@inject SymbolFormatter MtgSymbols
@inject CardText CardText

@inject NavigationManager Nav
@inject ILogger<DeckBuilder> Logger


<h1>@_deck.Name Builder</h1>

<div class="mb-3">
    <button title="Save Deck" type="button"
        class="btn btn-secondary" 
        disabled="@HasNoChanges"
        @onclick="CommitChangesAsync">
        Save Changes
    </button>
</div>

<div class="form-row align-items-center my-3">
    <div class="col-3">
        <input class="form-control" placeholder="Name" @onchange="SearchName" />
    </div>

    <div class="col-auto btn-group" role="group" aria-label="Color Buttons">
        @foreach (var (color, symbol) in Color.Symbols)
        {
            var active = _colorFilter.Contains(color) ? "active" : "";

            <button title="@color filter"
                    type="button"
                    class="btn btn-outline-secondary border-0 rounded @active"
                    @onclick="() => FilterColor(color)">
                <i class="ms ms-@symbol.ToLower() ms-cost"></i>
            </button>
        }
    </div>
</div>

<SavePrompt @bind-Result="_result">
    <SuccessMessage>
        Save was succesful, and values have been updated
    </SuccessMessage>
    <ErrorMessage>
        <p>There are conflicts while trying to save, and values have been updated. </p>
        <hr />
        <p>Save again to confirm</p>
    </ErrorMessage>
</SavePrompt>

<div class="row">
    <div class="col-7">
        <h3>Treasury</h3>

        <div class="list-group list-group-flush">
            @foreach (var (card, available) in Treasury)
            {
                var wantTotal = card.Wants.Sum(w => w.Amount);
                var previewId = $"{card.Id}-preview";

                <button type="button" title="Add @card.Name"
                    aria-controls="@previewId"
                    class="list-group-item list-group-item-action"
                    @oncontextmenu:preventDefault
                    @oncontextmenu="() => PreviewCard(card)"
                    @onclick="() => AddCardToDeck(card)">

                    <span class="row">
                        <span class="col-6"> @card.Name </span>
                        <span class="col-4"> @(MtgSymbols.Format(card.ManaCost).ToMarkupString()) </span>
                        <span class="col-2"> @(available - Math.Min(wantTotal, available)) </span>
                    </span>
                </button>

                @if (_preview == card.Id)
                {
                    <div id="@previewId" class="card card-body">
                        <img alt="@card.Name Image"
                            src="@card.ImageUrl.WithHttps()"
                            class=" img-fluid rounded" width="250px"/>
                    </div>
                }
            }
        </div>

        @if (Pages.HasMultiple)
        {
            var prevDisabled = Pages.HasPrevious ? "" : "disabled";
            var nextDisabled = Pages.HasNext ? "" : "disabled";

            <nav aria-label="Card Result Pages">
                <ul class="pagination justify-content-center pt-4">

                    <li class="page-item @prevDisabled">
                        <button class="page-link" disabled="@(!Pages.HasPrevious)"
                            @onclick="() => ApplyFilters(Pages.Current - 1)">
                            &laquo;
                        </button>
                    </li>

                    @for (int i = 0; i < Pages.Total; ++i)
                    {
                        var pageIndex = i;
                        var activePage = pageIndex == Pages.Current ? "active" : "";

                        <li class="page-item @activePage">
                            <button class="page-link" @onclick="() => ApplyFilters(pageIndex)">
                                @(pageIndex + 1)
                                <span class="sr-only">(current)</span>
                            </button>
                        </li>
                    }

                    <li class="page-item @nextDisabled">
                        <button class="page-link" disabled="@(!Pages.HasNext)"
                            @onclick="() => ApplyFilters(Pages.Current + 1)">
                            &raquo;
                        </button>
                    </li>

                </ul>
            </nav>
        }
    </div>

    <div class="col">
        <div id="deck-builder">
            <EditForm EditContext="@_deckEdit">
                <DataAnnotationsValidator />
                <ValidationSummary />

                <InputText @bind-Value="_deck.Name"/>
            </EditForm>

            <div id="deck-builder-cards" class="list-group list-group-flush">
                @foreach (var (card, group) in DeckCards)
                {
                    <button type="button" title="Remove @card.Name"
                        class="list-group-item list-group-item-action"
                        disabled="@(group.Amount <= 0)"
                        @onclick="() => RemoveCardFromDeck(card)">

                        <span class="row">
                            <span class="col-5"> @card.Name </span>
                            <span class="col-4"> @(MtgSymbols.Format(card.ManaCost).ToMarkupString()) </span>

                            <span class="col-3">
                                <span class="badge badge-pill badge-primary"> @(group.Actual?.Amount ?? 0) </span>
                                <span class="badge badge-pill badge-danger"> @(group.GiveBack?.Amount ?? 0) </span>
                                <span class="badge badge-pill badge-secondary"> @(group.Want?.Amount ?? 0) </span>
                            </span>
                        </span>
                    </button>
                }
            </div>
        </div>
    </div>
</div>


@code {

    [Parameter]
    public string UserId { get; set; }

    [Parameter]
    public int DeckId { get; set; } = default;

    [Parameter]
    public int PageSize { get; set; }


    private bool _isBusy;
    private readonly CancellationTokenSource _cancel = new();

    private SaveResult _result;
    private CardDbContext _dbContext;

    private IReadOnlyList<Card> _cards;
    private IReadOnlyDictionary<string, int> _boxAmounts;
    private string _preview;

    private PagedList<Card> _filteredCards;
    private readonly HashSet<string> _colorFilter = new(StringComparer.CurrentCultureIgnoreCase);
    private string _searchName;

    private Deck _deck;
    private EditContext _deckEdit;
    private Dictionary<string, QuantityGroup> _deckCards;



    private bool HasNoChanges =>
        !_dbContext.ChangeTracker.HasChanges();


    private IEnumerable<(Card, int amount)> Treasury =>
        _filteredCards
            .Select(c => (c, _boxAmounts.GetValueOrDefault(c.Id)));

    private Data.Pages Pages => _filteredCards.Pages;

    private IEnumerable<(Card, QuantityGroup)> DeckCards =>
        _cards
            .Where(c => _deckCards.TryGetValue(c.Id, out var cardGroup) && cardGroup.Total > 0)
            .Select(c => (c, _deckCards[c.Id]));


    private IQueryable<Deck> DeckForBuilder =>
        _dbContext.Decks
            .Where(d => d.Id == DeckId)
            .Include(d => d.Cards) // unbounded: keep eye on
            .Include(d => d.Wants) // unbounded: keep eye on
            .Include(d => d.GiveBacks) // unbounded: keep eye on
            .AsSplitQuery();



    protected override async Task OnInitializedAsync()
    {
        if (_isBusy)
        {
            return;
        }

        _isBusy = true;

        try
        {
            _dbContext = DbFactory.CreateDbContext();

            _cards = await _dbContext.Cards
                .Include(c => c.Colors)
                .OrderBy(c => c.Name)
                    .ThenBy(c => c.SetName)
                .ToListAsync(_cancel.Token); // unbounded, keep eye on

            _cancel.Token.ThrowIfCancellationRequested();

            _boxAmounts = await _dbContext.Amounts
                .Where(ca => ca.Location is Box)
                .GroupBy(ca => ca.CardId,
                    (CardId, cas) => 
                        new { CardId, Total = cas.Sum(ca => ca.Amount) })
                .ToDictionaryAsync(
                    ct => ct.CardId, ct => ct.Total, _cancel.Token);

            _cancel.Token.ThrowIfCancellationRequested();
        }
        catch (OperationCanceledException ex)
        {
            Logger.LogError(ex.ToString());
        }
        finally
        {
            _isBusy = false;
        }
    }


    protected override async Task OnParametersSetAsync()
    {
        if (_isBusy)
        {
            return;
        }

        _isBusy = true;

        try
        {
            _deck = await GetOrCreateDeckAsync();

            _deckEdit = new(_deck);

            _deckCards = GetDeckCardGroups(_deck)
                .ToDictionary(cg => cg.CardId);

            ApplyFilters();
        }

        catch (DbUpdateException ex)
        {
            Logger.LogError(ex.ToString());
        }
        catch (OperationCanceledException ex)
        {
            Logger.LogError(ex.ToString());
        }
        finally
        {
            _isBusy = false;
        }
    }


    private async Task<Deck> GetOrCreateDeckAsync()
    {
        if (DeckId != default)
        {
            var deck = await DeckForBuilder.SingleAsync(_cancel.Token);

            _cancel.Token.ThrowIfCancellationRequested();

            return deck;
        }

        var userValue = new []{ UserId };
        var user = await _dbContext.Users.FindAsync(userValue, _cancel.Token);

        _cancel.Token.ThrowIfCancellationRequested();

        if (user == null)
        {
            throw new ArgumentException(nameof(UserId));
        }

        var userDeckCount = await _dbContext.Decks
            .Where(d => d.OwnerId == UserId)
            .CountAsync(_cancel.Token);

        _cancel.Token.ThrowIfCancellationRequested();

        var newLoc = new Deck
        {
            Name = $"Deck #{userDeckCount + 1}",
            Owner = user
        };

        _dbContext.Decks.Attach(newLoc);

        return newLoc;
    }


    private IEnumerable<QuantityGroup> GetDeckCardGroups(Deck deck)
    {
        var amountsById = deck.Cards.ToDictionary(ca => ca.CardId);
        var takesById = deck.Wants.ToDictionary(w => w.CardId);
        var givesById = deck.GiveBacks.ToDictionary(g => g.CardId);

        var cardIds = amountsById.Keys
            .Union(takesById.Keys)
            .Union(givesById.Keys);

        return cardIds.Select(cid =>
            new QuantityGroup(
                amountsById.GetValueOrDefault(cid),
                takesById.GetValueOrDefault(cid),
                givesById.GetValueOrDefault(cid) ));
    }


    public async ValueTask DisposeAsync()
    {
        _cancel.Cancel();
        _cancel.Dispose();

        if (_dbContext is not null)
        {
            await _dbContext.DisposeAsync();
        }
    }


    private void PreviewCard(Card card)
    {
        if (_preview == card.Id)
        {
            _preview = null;
        }
        else
        {
            _preview = card.Id;
        }
    }


    private void FilterColor(string color)
    {
        if (_colorFilter.Contains(color))
        {
            _colorFilter.Remove(color);
        }
        else
        {
            _colorFilter.Add(color);
        }

        ApplyFilters();
    }


    private void SearchName(ChangeEventArgs eventArgs)
    {
        _searchName = eventArgs.Value?.ToString();
        
        ApplyFilters();
    }


    private void ApplyFilters(int pageIndex = 0)
    {
        const StringComparison ignoreCase = StringComparison.CurrentCultureIgnoreCase;

        var filter = _cards.AsEnumerable();

        if (!string.IsNullOrWhiteSpace(_searchName))
        {
            filter = filter
                .Where(c => c.Name
                    .Contains(_searchName, ignoreCase));
        }

        if (_colorFilter.Any())
        {
            filter = filter
                .Where(c => c.Colors
                    .Any(cl => _colorFilter.Contains(cl.Name) ));
        }

        _preview = null;
        _filteredCards = filter.ToPagedList(PageSize, pageIndex);
    }


    private void AddCardToDeck(Card card)
    {
        if (_deck == null || _deckCards == null)
        {
            return;
        }

        _result = SaveResult.None;

        var deckGroup = _deckCards.GetValueOrDefault(card.Id);

        if (deckGroup?.GiveBack?.Amount > 0)
        {
            deckGroup.GiveBack.Amount -= 1;
            return;
        }

        if (deckGroup?.Want is null)
        {
            // todo: add want limit

            var wantAmount = new Want
            {
                Card = card,
                Deck = _deck,
                Amount = 0,
            };

            _dbContext.Wants.Attach(wantAmount);

            if (deckGroup is null)
            {
                deckGroup = new(wantAmount);
                _deckCards.Add(card.Id, deckGroup);
            }
            else
            {
                deckGroup.Want = wantAmount;
            }
        }

        deckGroup.Want.Amount += 1;
    }


    private void RemoveCardFromDeck(Card card)
    {
        if (_deck == null || _deckCards == null)
        {
            return;
        }

        _result = SaveResult.None;

        if (!_deckCards.TryGetValue(card.Id, out var deckGroup))
        {
            Logger.LogError($"card {card.Id} is not in the deck");
            return;
        }

        if (deckGroup.Want?.Amount > 0)
        {
            deckGroup.Want.Amount -= 1;
            return;
        }

        var actualRemain = (deckGroup.Actual?.Amount ?? 0)
            - (deckGroup.GiveBack?.Amount ?? 0);

        if (actualRemain == 0)
        {
            // Logger.LogError($"there are no more of {card.Id} to remove");
            return;
        }

        if (deckGroup.GiveBack is null)
        {
            var returnAmount = new GiveBack
            {
                Card = deckGroup.Card,
                Deck = _deck,
                Amount = 0
            };

            _dbContext.GiveBacks.Attach(returnAmount);
            deckGroup.GiveBack = returnAmount;
        }

        deckGroup.GiveBack.Amount += 1;
    }



    private async Task CommitChangesAsync()
    {
        if (_deck == null || _deckCards == null)
        {
            return;
        }

        if (_isBusy)
        {
            return;
        }

        if (!_deckEdit.Validate())
        {
            return;
        }

        _isBusy = true;

        try
        {
            PrepareChanges();

            await _dbContext.SaveChangesAsync(_cancel.Token);

            _cancel.Token.ThrowIfCancellationRequested();

            if (_deck.GiveBacks.Any() || _deck.Wants.Any())
            {
                Nav.NavigateTo($"/Decks/Exchange/{_deck.Id}", true);
            }
            else
            {
                _result = SaveResult.Success;
            }
        }
        catch (DbUpdateConcurrencyException ex)
        {
            _result = SaveResult.Error;
            await UpdateDeckAsync(ex);
        }
        catch (DbUpdateException ex)
        {
            Logger.LogError(ex.ToString());
        }
        catch (OperationCanceledException ex)
        {
            Logger.LogError(ex.ToString());
        }

        finally
        {
            _isBusy = false;
        }
    }


    private void PrepareChanges()
    {
        foreach (var want in _deck.Wants)
        {
            if (want.Amount == 0)
            {
                _dbContext.Wants.Remove(want);
            }
            // detaches when saved after a remove
            else if (_dbContext.Entry(want).State == EntityState.Detached)
            {
                _dbContext.Wants.Add(want);
            }
        }

        foreach (var giveBack in _deck.GiveBacks)
        {
            if (giveBack.Amount == 0)
            {
                _dbContext.GiveBacks.Remove(giveBack);
            }
            else if (_dbContext.Entry(giveBack).State == EntityState.Detached)
            {
                _dbContext.GiveBacks.Add(giveBack);
            }
        }

        var deckEntry = _dbContext.Entry(_deck);

        if (deckEntry.State == EntityState.Unchanged)
        {
            deckEntry.State = EntityState.Modified;
        }

        _deck.UpdateColors(CardText);
    }


    private async Task UpdateDeckAsync(DbUpdateConcurrencyException ex)
    {
        if (HasNoDeckConflicts(ex))
        {
            return;
        }

        if (_cancel.IsCancellationRequested)
        {
            return;
        }

        Deck dbDeck = default;

        try
        {
            dbDeck = await DeckForBuilder
                .AsNoTracking()
                .SingleOrDefaultAsync(_cancel.Token);
        }
        catch (OperationCanceledException)
        { }

        if (_cancel.IsCancellationRequested)
        {
            return;
        }

        if (dbDeck == default)
        {
            _dbContext.Decks.Add(_deck);
            return;
        }

        MergeDeckRemoves(dbDeck);
        TrackNewDeckCards(dbDeck);

        MergeDeckCardConflicts(dbDeck);
        CapDeletes();

        _dbContext.MatchToken(_deck, dbDeck);
    }


    private bool HasNoDeckConflicts(DbUpdateConcurrencyException ex)
    {
        var deckConflict = ex.Entries<Location>().SingleOrDefault();

        if (deckConflict is not null && deckConflict.Entity.Id == _deck.Id)
        {
            return false;
        }

        var conflictsInDeck = ex.Entries<CardAmount>()
            .Select(ca => ca.Entity.CardId)
            .Intersect(_deckCards.Keys);

        return !conflictsInDeck.Any();
    }


    private void MergeDeckRemoves(Deck dbDeck)
    {
        var removedCards = _deck.Cards
            .GroupJoin( dbDeck.Cards,
                local => local.CardId, db => db.CardId,
                (local, dbs) =>
                    (local, noDb: !dbs.Any()))
            .Where(ln => ln.noDb)
            .Select(ln => ln.local);

        foreach(var removedCard in removedCards)
        {
            removedCard.Amount = 0;
            _dbContext.Amounts.Remove(removedCard);
        }


        var removedWants = _deck.Wants
            .GroupJoin( dbDeck.Wants,
                wt => (wt.CardId, wt.DeckId),
                db => (db.CardId, db.DeckId),
                (local, dbs) =>
                    (local, noDb: !dbs.Any()))
            .Where(ln => ln.noDb)
            .Select(ln => ln.local);

        foreach (var removedWant in removedWants)
        {
            if (_dbContext.Entry(removedWant).State == EntityState.Unchanged)
            {
                removedWant.Amount = 0;
                _dbContext.Wants.Remove(removedWant);
            }
            else
            {
                _dbContext.Wants.Add(removedWant);
            }
        }


        var removedGiveBacks = _deck.GiveBacks
            .GroupJoin( dbDeck.GiveBacks,
                gb => (gb.CardId, gb.DeckId),
                db => (db.CardId, db.DeckId),
                (local, dbs) =>
                    (local, noDb: !dbs.Any()))
            .Where(ln => ln.noDb)
            .Select(ln => ln.local);

        foreach (var removedGive in removedGiveBacks)
        {
            if (_dbContext.Entry(removedGive).State == EntityState.Unchanged)
            {
                removedGive.Amount = 0;
                _dbContext.GiveBacks.Remove(removedGive);
            }
            else
            {
                _dbContext.GiveBacks.Add(removedGive);
            }
        }
    }


    private void MergeDeckCardConflicts(Deck dbDeck)
    {
        foreach (var dbCard in dbDeck.Cards)
        {
            if (!_deckCards.TryGetValue(dbCard.CardId, out var localGroup)
                || localGroup.Actual is null)
            {
                continue;
            }

            var localCard = localGroup.Actual;

            if (_dbContext.Entry(localCard).State == EntityState.Unchanged)
            {
                localCard.Amount = dbCard.Amount;
            }

            _dbContext.MatchToken(localCard, dbCard);
        }


        foreach (var dbWant in dbDeck.Wants)
        {
            if (!_deckCards.TryGetValue(dbWant.CardId, out var localGroup)
                || localGroup.Want is null)
            {
                continue;
            }

            var localWant = localGroup.Want;

            if (_dbContext.Entry(localWant).State == EntityState.Unchanged)
            {
                localWant.Amount = dbWant.Amount;
            }

            _dbContext.MatchToken(localWant, dbWant);
        }


        foreach (var dbGiveBack in dbDeck.GiveBacks)
        {
            if (!_deckCards.TryGetValue(dbGiveBack.CardId, out var localGroup)
                || localGroup.GiveBack is null)
            {
                continue;
            }

            var localReturn = localGroup.GiveBack;

            if (_dbContext.Entry(localReturn).State == EntityState.Unchanged)
            {
                localReturn.Amount = dbGiveBack.Amount;
            }

            _dbContext.MatchToken(localReturn, dbGiveBack);
        }
    }


    private void TrackNewDeckCards(Deck dbDeck)
    {
        foreach (var dbCard in dbDeck.Cards)
        {
            var hasGroup = _deckCards.TryGetValue(dbCard.CardId, out var localGroup);

            if (hasGroup && localGroup.Actual is not null)
            {
                continue;
            }

            if (hasGroup)
            {
                localGroup.Actual = dbCard;
            }
            else
            {
                localGroup = new(dbCard);
                _deckCards.Add(dbCard.CardId, localGroup);
            }

            _dbContext.Amounts.Attach(dbCard);
        }


        foreach (var dbWant in dbDeck.Wants)
        {
            var hasGroup = _deckCards.TryGetValue(dbWant.CardId, out var localGroup);

            if (hasGroup && localGroup.Want is not null)
            {
                continue;
            }

            if (hasGroup)
            {
                localGroup.Want = dbWant;
            }
            else
            {
                localGroup = new(dbWant);
                _deckCards.Add(dbWant.CardId, localGroup);
            }

            _dbContext.Wants.Attach(dbWant);
        }


        foreach (var dbGiveBack in dbDeck.GiveBacks)
        {
            var hasGroup = _deckCards.TryGetValue(dbGiveBack.CardId, out var localGroup);

            if (hasGroup && localGroup.GiveBack is not null)
            {
                continue;
            }

            if (hasGroup)
            {
                localGroup.GiveBack = dbGiveBack;
            }
            else
            {
                localGroup = new(dbGiveBack);
                _deckCards.Add(dbGiveBack.CardId, localGroup);
            }

            _dbContext.GiveBacks.Attach(dbGiveBack);
        }
    }


    private void CapDeletes()
    {
        foreach(var cardGroup in _deckCards.Values)
        {
            if (cardGroup.GiveBack is null)
            {
                continue;
            }

            var currentReturn = cardGroup.GiveBack.Amount;
            var capAmount = cardGroup.Actual?.Amount ?? currentReturn;

            cardGroup.GiveBack.Amount = Math.Min(currentReturn, capAmount);
        }
    }
}