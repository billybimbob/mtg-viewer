@using Microsoft.Extensions.DependencyInjection
@namespace MTGViewer.Components

@inherits OwningComponentBase

@inject SymbolFormatter MtgSymbols
@inject NavigationManager Nav


<h1>Add New Card(s)</h1>

@if (!_matches.Any())
{
    <hr />
    <EditForm EditContext="@_searchEdit" OnValidSubmit="@SearchForCardAsync">
        <DataAnnotationsValidator />
        <div class="row">

            <div class="col order-last">
                <ValidationSummary role="alert"/>

                <h5> Or Operator </h5>
                <p> 
                    All of the parameters (except Converted Mana Cost) can search with multiple values 
                    specified by adding the pipe character between each value. These multiple values act 
                    as a logical <strong>or</strong> for the search.
                </p>

                <p> Example or for Name: <code>jace|ajani|nissa, worldwaker</code> </p>

                <h5> And Operator </h5>
                <p>
                    Parameters that can have more than one value per card (Types, Supertypes, and Subtypes) 
                    can also have multiple values specified by adding a comma or space between each value. 
                    These multiple values act as a logical <strong>and</strong> for the search.
                </p>

                <p> Example and for Subtype(s): <code>bear,bird</code> or <code>bear bird</code> </p>
                <p> 
                    Note that <strong>either</strong> the <i>and</i> or the <i>or</i> operator can be
                    applied on a given parameter value, not both.
                </p>

                <hr/>
                <h5> Type Parameters </h5>

                <p>
                    All of the type parameters are specified on the type line of the card (the center description),
                    which is broken down into three different categories:
                </p>

                <dl class="row">
                    <dt class="col-2"> Supertypes </dt>
                    <dd class="col">
                        <p> Type information that is the most left of the type line </p>
                        <p> Examples: Basic, Legendary, Snow </p>
                    </dd>

                    <div class="w-100"></div>

                    <dt class="col-2"> Types </dt>
                    <dd class="col">
                        <p> Type information that follows immediately to the left of the dash. </p>
                        <p> Examples: Instant, Creature, Land, Planeswalker </p>
                    </dd>

                    <div class="w-100"></div>

                    <dt class="col-2"> Subtypes </dt>
                    <dd class="col">
                        <p> Type information that appears to the right of the dash. </p>
                        <p> Examples: Equipment, Aura, Human, Vampire </p>
                    </dd>
                </dl>
            </div>

            <div class="col-4">
                <p> Enter the card search parameters below </p>

                <div class="form-group">
                    <InputText @bind-Value="_search.Name" 
                        placeholder="@_search.DisplayName(c => c.Name)" 
                        class="form-control" />
                </div>

                <div class="form-group">
                    <InputNumber @bind-Value="_search.Cmc" min="0"
                        placeholder="@_search.DisplayName(c => c.Cmc)" 
                        class="form-control" />
                </div>

                <div class="form-group">
                    @foreach (var (color, symbol) in Color.Symbols)
                    {
                        var toggleId = $"{color}Toggle";
                        var active = _pickedColors.Contains(color) ? "active" : string.Empty;

                        <button title="@toggleId"
                            type="button"
                            class="btn btn-outline-secondary border-0 rounded @active"
                            @onclick="() => ColorToggle(color)">
                            <i class="ms ms-@symbol.ToLower() ms-cost"></i>
                        </button>
                    }

                    <div class="form-check mt-2 ml-2">
                        <input class="form-check-input" id="@nameof(_multiColored)" 
                            type="checkbox" 
                            checked="@_multiColored"
                            @onchange="MultiColorSwitch" />

                        <label class="form-check-label" for="@nameof(_multiColored)">
                            Multicolored Only
                        </label>
                    </div>
                </div>

                <div class="form-group">
                    <InputText @bind-Value="_search.Supertypes"
                        placeholder="@_search.DisplayName(c => c.Supertypes)"
                        class="form-control" />
                </div>

                <div class="form-group">
                    <InputText @bind-Value="_search.Types"
                        placeholder="@_search.DisplayName(c => c.Types)"
                        class="form-control" />
                </div>

                <div class="form-group">
                    <InputText @bind-Value="_search.Subtypes"
                        placeholder="@_search.DisplayName(c => c.Subtypes)"
                        class="form-control" />
                </div>

                <div class="form-group">
                    <InputText @bind-Value="_search.SetName" 
                        placeholder="@_search.DisplayName(c => c.SetName)" 
                        class="form-control" />
                </div>

                <div class="form-row mb-3">
                    @for (int i = 0; i < Rarity.Values.Count; ++i)
                    {
                        var rarity = Rarity.Values[i];
                        var toggleId = $"{rarity}-toggle";
                        var picked = _pickedRarities.Contains(rarity);

                        <div class="col form-check form-check-inline ml-2">

                            <input class="form-check-input" id="@toggleId"
                                type="checkbox" checked="@picked" 
                                @onclick="() => RarityToggle(rarity)"
                                value="@rarity" />

                            <label class="form-check-label" for="@toggleId"> @rarity </label>
                        </div>

                        @if (i % 2 == 1)
                        {
                            <div class="w-100"></div>
                        }
                    }
                </div>

                <div class="form-group">
                    <InputText @bind-Value="_search.Artist" 
                        placeholder="@_search.DisplayName(c => c.Artist)" 
                        class="form-control" />
                </div>

                <div class="form-group">
                    <InputText @bind-Value="_search.Power" 
                        placeholder="@_search.DisplayName(c => c.Power)" 
                        class="form-control" />
                </div>

                <div class="form-group">
                    <InputText @bind-Value="_search.Toughness" 
                        placeholder="@_search.DisplayName(c => c.Toughness)" 
                        class="form-control" />
                </div>

                <div class="form-group">
                    <InputText @bind-Value="_search.Loyalty" 
                        placeholder="@_search.DisplayName(c => c.Loyalty)" 
                        class="form-control" />
                </div>

                <div class="form-group">
                    <button type="submit" class="btn btn-secondary"> Search </button>

                    <button type="button" class="btn btn-secondary" 
                        @onclick="Reset" title="Reset"> 
                        Reset </button>
                </div>
            </div>
        </div>
    </EditForm>
}
else
{
    <div class="form-group">
        <button title="Add Button" type="button"
            @onclick="AddNewCardsAsync" disabled="@CannotAdd" 
            class="btn btn-secondary">
            Add Cards/Amounts </button>

        <button title="Reset Button" type="button"
            @onclick="Reset" 
            class="btn btn-secondary">
            Reset </button>
    </div>

    <div class="form-row align-items-center my-3">

        <div class="col-3">
            <input class="form-control" placeholder="Name" @bind="_matchName" />
        </div>

        <div class="col-auto btn-group" role="group" aria-label="Color Buttons">
            @foreach (var (color, symbol) in Color.Symbols)
            {
                var active = _pickedColors.Contains(color) ? "active" : "";

                <button title="@color filter"
                        type="button"
                        class="btn btn-outline-secondary border-0 rounded @active"
                        @onclick="() => ColorToggle(color)">
                    <i class="ms ms-@symbol.ToLower() ms-cost"></i>
                </button>
            }
        </div>
    </div>

    <table class="table">
        <thead>
            <th scope="col"> @Entities.DisplayName((Card c) => c.Name) </th>
            <th scope="col"> @Entities.DisplayName((Card c) => c.ManaCost) </th>
            <th scope="col"> @Entities.DisplayName((Card c) => c.SetName) </th>
            <th scope="col"> @Entities.DisplayName((Card c) => c.Rarity) </th>
            <th scope="col"> Amount </th>
        </thead>
        <tbody>
            @foreach (var (match, amount) in _matches)
            {
                @if (MatchPassesFilters(match))
                {
                    <tr>
                        <td> 
                            <HoverCard Card="(CardPreview)match">
                                <span class="btn-link">@match.Name</span> 
                            </HoverCard> 
                        </td>
                        <td> @MtgSymbols.Format(match.ManaCost).ToMarkupString() </td>
                        <td> @match.SetName </td>
                        <td> @match.Rarity </td>
                        <td>
                            <input title="@match.Name Amount" 
                                type="number" min="0" value="@amount" 
                                @onchange="e => UpdateAmount(e, match)"
                                class="form-control w-50" />
                        </td>
                    </tr>
                }
            }
        </tbody>
    </table>

    <div class="form-group">
        <button title="More Results" type="button"
            @onclick="SearchForCardAsync" 
            disabled="@(!HasMore)" class="btn btn-secondary">
            Load More</button>
    </div>
}


@code {
    private bool HasMore => _nextPage >= 0;

    private bool CannotAdd => _matches.All(kv => kv.Value <= 0);


    private readonly CancellationTokenSource _cancel = new();
    private bool _isBusy;

    private bool _multiColored;
    private readonly HashSet<string> _pickedColors = new(StringComparer.OrdinalIgnoreCase);
    private readonly HashSet<string> _pickedRarities = new(StringComparer.OrdinalIgnoreCase);

    private readonly CardSearch _search = new();
    private EditContext _searchEdit;
    private ValidationMessageStore _resultErrors;

    private readonly Dictionary<Card, int> _matches = new();
    private string _matchName;
    private int _nextPage;


    protected override void OnInitialized()
    {
        _searchEdit = new(_search);
        _resultErrors = new(_searchEdit);

        Reset();

        _searchEdit.OnValidationRequested += ClearErrors;
        _searchEdit.OnFieldChanged += ClearErrors;
    }


    protected override void Dispose(bool disposing)
    {
        _searchEdit.OnValidationRequested -= ClearErrors;
        _searchEdit.OnFieldChanged -= ClearErrors;

        _cancel.Cancel();
        _cancel.Dispose();
    }


    private void ClearErrors(object sender, ValidationRequestedEventArgs args)
    {
        _resultErrors.Clear();
        _searchEdit.NotifyValidationStateChanged();
    }


    private void ClearErrors(object sender, FieldChangedEventArgs args)
    {
        var idField = _searchEdit.Field(nameof(CardSearch.Id));

        _resultErrors.Clear(idField);
        _resultErrors.Clear(args.FieldIdentifier);

        _searchEdit.NotifyValidationStateChanged();
    }


    private void NoMatchError()
    {
        var idField = _searchEdit.Field(nameof(CardSearch.Id));
        var noMatch = new []{ "No matches were found" };

        _resultErrors.Add(idField, noMatch);
        _searchEdit.NotifyValidationStateChanged();
    }


    private void MultiColorSwitch(ChangeEventArgs args)
    {
        if (!bool.TryParse(args.Value?.ToString(), out bool value))
        {
            return;
        }

        _multiColored = value;

        var colorField = _searchEdit.Field(nameof(CardSearch.Colors));

        _searchEdit.NotifyFieldChanged(colorField);
    }


    private void ColorToggle(string color)
    {
        if (_pickedColors.Contains(color))
        {
            _pickedColors.Remove(color);
        }
        else
        {
            _pickedColors.Add(color);
        }

        var colorField = _searchEdit.Field(nameof(CardSearch.Colors));

        _searchEdit.NotifyFieldChanged(colorField);
    }


    private void RarityToggle(string rarity)
    {
        if (_pickedRarities.Contains(rarity))
        {
            _pickedRarities.Remove(rarity);
        }
        else
        {
            _pickedRarities.Add(rarity);
        }

        var rarityField = _searchEdit.Field(nameof(CardSearch.Rarity));

        _searchEdit.NotifyFieldChanged(rarityField);
    }


    private async Task SearchForCardAsync()
    {
        if (_isBusy)
        {
            return;
        }

        if (!HasMore)
        {
            return;
        }

        _isBusy = true;

        var logger = ScopedServices.GetRequiredService<ILogger<Create>>();
        var fetch = ScopedServices.GetRequiredService<MTGFetchService>();

        try
        {
            PrepareSearch();

            var result = await fetch.MatchAsync(_search, _nextPage);

            _cancel.Token.ThrowIfCancellationRequested();

            foreach (var match in result)
            {
                _matches.Add(match, 0);
            }

            if (!_matches.Any())
            {
                NoMatchError();
            }
            else if (result.Any())
            {
                _nextPage++;
            }
            else
            {
                _nextPage = -1;
            }
        }
        catch (OperationCanceledException ex)
        {
            logger.LogError(ex.ToString());
        }
        finally
        {
            _isBusy = false;
        }
    }


    private void PrepareSearch()
    {
        var colorJoin = _multiColored ? MTGFetchService.And : MTGFetchService.Or;

        _search.Colors = string.Join(colorJoin, _pickedColors);

        _search.Rarity = string.Join(MTGFetchService.Or, _pickedRarities);
    }


    private void UpdateAmount(ChangeEventArgs args, Card card)
    {
        if (int.TryParse(args.Value?.ToString(), out int newAmount)
            && newAmount >= 0)
        {
            _matches[card] = newAmount;
        }
    }


    private bool MatchPassesFilters(Card match)
    {
        const StringComparison ignoreCase = StringComparison.CurrentCultureIgnoreCase;

        var matchColors = match.Colors.Select(c => c.Name);

        bool nameMatches = string.IsNullOrWhiteSpace(_matchName) 
            || match.Name.Contains(_matchName, ignoreCase);

        bool colorMatches = _pickedColors.Count == 0 
            || _pickedColors.Overlaps(matchColors);

        return nameMatches && colorMatches;
    }


    private void Reset()
    {
        _pickedColors.Clear();

        _matches.Clear();
        _nextPage = 0;

        _search.Name = default;
        _search.Cmc = default;
        _search.Colors = default;
        _search.Rarity = default;
        _search.SetName = default;

        _search.Supertypes = default;
        _search.Types = default;
        _search.Subtypes = default;

        _search.Artist = default;
        _search.Power = default;
        _search.Toughness = default;
        _search.Loyalty = default;

        // force data validation, might be inefficient
        _searchEdit.Validate();
    }


    private async Task AddNewCardsAsync()
    {
        if (_isBusy)
        {
            return;
        }

        var addedAmounts = _matches
            .Where(kv => kv.Value > 0)
            .Select(kv => (card: kv.Key, amount: kv.Value))
            .ToList();

        if (!addedAmounts.Any())
        {
            return;
        }

        var logger = ScopedServices.GetRequiredService<ILogger<Create>>();

        _isBusy = true;

        try
        {
            await SaveNewCardsAsync(addedAmounts.Select(ca => ca.card));

            await AddAmountsAsync(addedAmounts);

            Nav.NavigateTo("/Cards", true);
        }

        catch (DbUpdateException e)
        {
            logger.LogError($"failed to add new cards {e}");
        }
        catch (OperationCanceledException e)
        {
            logger.LogError($"cancel error: {e}");
        }
        finally
        {
            _isBusy = false;
        }
    }


    private async Task SaveNewCardsAsync(IEnumerable<Card> cards)
    {
        var dbContext = ScopedServices.GetRequiredService<CardDbContext>();

        var cardIds = cards.Select(c => c.Id).ToArray();

        var existingIds = await dbContext.Cards
            .Select(c => c.Id)
            .Where(cid => cardIds.Contains(cid))
            .ToListAsync(_cancel.Token);

        var newCards = cards
            .ExceptBy(existingIds, c => c.Id)
            .ToList();

        if (!newCards.Any())
        {
            return;
        }

        dbContext.Cards.AddRange(newCards);

        await dbContext.SaveChangesAsync(_cancel.Token);
    }


    private async Task AddAmountsAsync(IEnumerable<(Card card, int amount)> newAmounts)
    {
        var treasury = ScopedServices.GetRequiredService<ITreasury>();

        var returns = newAmounts
            .Select(ca => new CardReturn(ca.card, ca.amount))
            .ToList();

        await treasury.ReturnAsync(returns, _cancel.Token);
    }
}