@using System
@using System.Linq
@using System.Linq.Expressions
@using MTGViewer.Data

@namespace MTGViewer.Components
@inject IDbContextFactory<CardDbContext> DbFactory


<h1>Card Collection</h1>

<div>
    <a class="btn btn-secondary" href="Cards/Create">Add Card</a>
    <a class="btn btn-secondary" href="Boxes/">Shared Collection</a>
</div>

<div class="my-3">
    <input class="formcontrol" placeholder="Name" @onchange="SearchNameAsync" />

    <div class="btn-group" role="group" aria-label="Color Buttons">
        @foreach (var color in Data.Color.COLORS)
        {
            var active = _colorFilter.Contains(color.Key) ? "active" : "";

            <button title="@color.Key filter"
                    type="button"
                    class="btn btn-outline-secondary border-0 rounded @active"
                    @onclick="() => FilterColorAsync(color.Key)">
                <span class="ms ms-@color.Value ms-cost"> </span>
            </button>
        }
    </div>

    <button @onclick="() => FetchCardsAsync(Cards.Pages.Current)"
        class="btn btn-secondary" >
        Refresh</button>
</div>

<table class="table">
    <thead>
        <tr>
            <th>
                <button @onclick="() => ReorderCardsAsync(c => c.Name)"
                    class="btn btn-link text-left pl-0 @BoldIfActive(c => c.Name)" >
                    Card Name
                </button>
            </th>
            <th>
                <button @onclick="() => ReorderCardsAsync(c => c.ManaCost)"
                    class="btn btn-link text-left pl-0 @BoldIfActive(c => c.ManaCost)">
                    Mana Cost
                </button>
            </th>
            <th>
                <button @onclick="() => ReorderCardsAsync(c => c.SetName)"
                    class="btn btn-link text-left pl-0 @BoldIfActive(c => c.SetName)" >
                    Set
                </button>
            </th>
            <th>
                <button @onclick="() => ReorderCardsAsync(c => c.Rarity)"
                    class="btn btn-link text-left pl-0 @BoldIfActive(c => c.Rarity)" >
                    Rarity
                </button>
            </th>
            <th>
                <button @onclick="() => ReorderCardsAsync(c => c.Amounts)"
                    class="btn btn-link text-left pl-0 @BoldIfActive(c => c.Amounts)" >
                    Total Amount
                </button>
            </th>
            <th></th>
        </tr>
    </thead>

    <tbody>
        @foreach (var card in Cards)
        {
            <tr>
                <td>
                    <a title="Details @card.Name"
                       href="/Cards/Details/?id=@card.Id"
                       class="fw-bold">
                       @card.Name
                    </a>
                </td>
                <td>
                    @foreach (var cost in card.GetManaSymbols())
                    {
                        <span class="m-1 ms ms-@cost ms-cost"></span>
                    }
                </td>
                <td>@card.SetName</td>
                <td>@card.Rarity</td>
                <td>@card.Amounts.Sum(ca => ca.Amount)</td>

                <td>
                    @if (IsSignedIn)
                    {
                        <a title="Suggest @card.Name"
                           href="/Transfers/Suggest/@card.Id"
                           class="btn btn-secondary">
                           Suggest </a>
                    }
                </td>
            </tr>
        }
    </tbody>
</table>

@{
    var prevDisabled = Cards.Pages.HasPrevious ? "" : "disabled";
    var nextDisabled = Cards.Pages.HasNext ? "" : "disabled";
}

@if (Cards.Pages.HasMultiple)
{
    <nav aria-label="Card Result Pages">
        <ul class="pagination justify-content-center">

            <li class="page-item @prevDisabled">
                <button class="page-link" disabled="@(!Cards.Pages.HasPrevious)"
                    @onclick="() => FetchCardsAsync(Cards.Pages.Current - 1)">
                    Previous
                </button>
            </li>

            @for (int i = 0; i < Cards.Pages.Total; ++i)
            {
                var pageIndex = i;
                var activePage = pageIndex == Cards.Pages.Current ? "active" : "";

                <li class="page-item @activePage">
                    <button class="page-link" @onclick="() => FetchCardsAsync(pageIndex)">
                        @(pageIndex + 1)
                        @* <span class="sr-only">(current)</span> *@
                    </button>
                </li>
            }

            <li class="page-item @nextDisabled">
                <button class="page-link" disabled="@(!Cards.Pages.HasNext)"
                    @onclick="() => FetchCardsAsync(Cards.Pages.Current + 1)">
                    Next
                </button>
            </li>

        </ul>
    </nav>
}


@code {

    [Parameter]
    public bool IsSignedIn { get; set; } = false;

    [Parameter]
    public int PageSize { get; set; }

    private PagedList<Card> Cards { get; set; }


    private bool _isBusy;

    private readonly HashSet<string> _colorFilter = new();
    private string _searchName;

    private string _orderProperty;
    private bool _isReversed;


    protected override void OnInitialized()
    {
        _colorFilter.Clear();
        _orderProperty = null;
        _searchName = string.Empty;

        base.OnInitialized();
    }

    

    protected override async Task OnParametersSetAsync()
    {
        await FetchCardsAsync();
        await base.OnParametersSetAsync();
    }


    private async Task FetchCardsAsync(int pageIndex = 0)
    {
        if (_isBusy)
        {
            return;
        }

        var totalPages = Cards?.Pages.Total;

        if (pageIndex < 0 || totalPages > 0 && pageIndex >= totalPages)
        {
            return;
        }

        _isBusy = true;
        try
        {
            await using var dbContext = DbFactory.CreateDbContext();

            Cards = await FilteredCards(dbContext)
                .ToPagedListAsync(PageSize, pageIndex);
        }
        finally
        {
            _isBusy = false;
        }
    }


    private IQueryable<Card> FilteredCards(CardDbContext dbContext)
    {
        var cards = dbContext.Cards
            .Include(c => c.Colors)
            .Include(c => c.Amounts)
                // unbounded: keep eye on
            .AsSplitQuery()
            .AsNoTrackingWithIdentityResolution();


        if (!string.IsNullOrWhiteSpace(_searchName))
        {
            cards = cards.Where(c => 
                c.Name.ToLower().Contains(_searchName));
        }

        if (_colorFilter.Any())
        {
            cards = cards.Where(c =>
                c.Colors.Any(clr => _colorFilter.Contains(clr.Name.ToLower())) );
        }

        return OrderedQuery(cards);
    }


    private IOrderedQueryable<Card> OrderedQuery(IQueryable<Card> cards)
    {
        var isAscending = _orderProperty switch
        {
            nameof(Card.ManaCost) => true,
            nameof(Card.SetName) => true,
            nameof(Card.Rarity) => false,
            nameof(Card.Amounts) => false,
            _ => true
        };

        IOrderedQueryable<Card> PrimaryOrder<T>(Expression<Func<Card, T>> property) =>
            isAscending ^ _isReversed
                ? cards.OrderBy(property)
                : cards.OrderByDescending(property);

        return _orderProperty switch
        {
            nameof(Card.ManaCost) => 
                PrimaryOrder(c => c.Cmc)
                    .ThenBy(c => c.Name)
                    .ThenBy(c => c.SetName),

            nameof(Card.SetName) =>
                PrimaryOrder(c => c.SetName)
                    .ThenBy(c => c.Name),

            nameof(Card.Rarity) => 
                PrimaryOrder(c => c.Rarity)
                    .ThenBy(c => c.Name)
                    .ThenBy(c => c.SetName),

            nameof(Card.Amounts) => 
                PrimaryOrder(c => c.Amounts.Sum(ca => ca.Amount))
                    .ThenBy(c => c.Name)
                    .ThenBy(c => c.SetName),

            _ => PrimaryOrder(c => c.Name)
                    .ThenBy(c => c.SetName)
        };
    }


    private string MemberName<T>(Expression<Func<Card, T>> property) =>
        (property.Body as MemberExpression)?.Member.Name;

    private string BoldIfActive<T>(Expression<Func<Card, T>> property) =>
        _orderProperty == null || MemberName(property) != _orderProperty
            ? ""
            : "font-weight-bold";


    private Task FilterColorAsync(string color)
    {
        if (_colorFilter.Contains(color))
        {
            _colorFilter.Remove(color);
        }
        else
        {
            _colorFilter.Add(color);
        }

        return FetchCardsAsync();
    }


    private Task SearchNameAsync(ChangeEventArgs eventArgs)
    {
        _searchName = eventArgs.Value?.ToString();
        
        return FetchCardsAsync();
    }


    private Task ReorderCardsAsync<T>(Expression<Func<Card, T>> property)
    {
        var newOrder = MemberName(property);
        var oldOrder = _orderProperty;

        if (newOrder is null)
        {
            return Task.CompletedTask;
        }

        _isReversed = newOrder == oldOrder && !_isReversed;
        _orderProperty = newOrder;

        return FetchCardsAsync();
    }
}