@using System
@using System.Linq
@using System.Linq.Expressions

@namespace MTGViewer.Components

@inject IDbContextFactory<CardDbContext> DbFactory
@inject MTGSymbols MtgSymbols


<h1>Card Collection</h1>

<div>
    <a class="btn btn-secondary" href="Cards/Create">Add Card</a>
    <a class="btn btn-secondary" href="Boxes/">Shared Collection</a>

    <button class="btn btn-secondary" 
        @onclick="() => RefreshCardsAsync()" > 
        Refresh </button>
</div>

<div class="my-3">
    <input class="formcontrol" placeholder="Name" @onchange="SearchName" />

    <div class="btn-group" role="group" aria-label="Color Buttons">
        @foreach (var (color, symbol) in Color.Symbols)
        {
            var active = _colorFilter.Contains(color) ? "active" : "";

            <button title="@color filter"
                    type="button"
                    class="btn btn-outline-secondary border-0 rounded @active"
                    @onclick="() => FilterColor(color)">
                <i class="ms ms-@symbol ms-cost"></i>
            </button>
        }
    </div>
</div>

<table class="table">
    <thead>
        <tr>
            <th>
                <button @onclick="() => ReorderCards(c => c.Name)"
                    class="btn btn-link text-left pl-0 @BoldIfActive(c => c.Name)">
                    Card Name
                </button>
            </th>
            <th>
                <button @onclick="() => ReorderCards(c => c.ManaCost)"
                    class="btn btn-link text-left pl-0 @BoldIfActive(c => c.ManaCost)">
                    Mana Cost
                </button>
            </th>
            <th>
                <button @onclick="() => ReorderCards(c => c.SetName)"
                    class="btn btn-link text-left pl-0 @BoldIfActive(c => c.SetName)">
                    Set
                </button>
            </th>
            <th>
                <button @onclick="() => ReorderCards(c => c.Rarity)"
                    class="btn btn-link text-left pl-0 @BoldIfActive(c => c.Rarity)">
                    Rarity
                </button>
            </th>
            <th>
                <button @onclick="() => ReorderCards(c => c.Amounts)"
                    class="btn btn-link text-left pl-0 @BoldIfActive(c => c.Amounts)">
                    Total Amount
                </button>
            </th>
            <th></th>
        </tr>
    </thead>

    <tbody>
        @foreach (var card in Cards)
        {
            <tr>
                <td>
                    <a title="Details @card.Name"
                       href="/Cards/Details/@card.Id"
                       class="fw-bold">
                       @card.Name
                    </a>
                </td>

                <td> @(MtgSymbols.Format<ManaTranslator>(card.ManaCost).ToMarkupString()) </td>
                <td> @card.SetName </td>
                <td> @card.Rarity </td>
                <td> @CardTotal(card) </td>
                @* <td>@card.Amounts.Sum(ca => ca.Amount)</td> *@

                <td>
                    @if (IsSignedIn)
                    {
                        <a title="Suggest @card.Name"
                           href="/Transfers/Suggest/@card.Id"
                           class="btn btn-secondary">
                           Suggest </a>
                    }
                </td>
            </tr>
        }
    </tbody>
</table>

@{
    var prevDisabled = Cards.Pages.HasPrevious ? "" : "disabled";
    var nextDisabled = Cards.Pages.HasNext ? "" : "disabled";
}

@if (Cards.Pages.HasMultiple)
{
    <nav aria-label="Card Result Pages">
        <ul class="pagination justify-content-center">

            <li class="page-item @prevDisabled">
                <button class="page-link" disabled="@(!Cards.Pages.HasPrevious)"
                    @onclick="() => FilterCards(Cards.Pages.Current - 1)">
                    Previous
                </button>
            </li>

            @for (int i = 0; i < Cards.Pages.Total; ++i)
            {
                var pageIndex = i;
                var activePage = pageIndex == Cards.Pages.Current ? "active" : "";

                <li class="page-item @activePage">
                    <button class="page-link" @onclick="() => FilterCards(pageIndex)">
                        @(pageIndex + 1)
                        @* <span class="sr-only">(current)</span> *@
                    </button>
                </li>
            }

            <li class="page-item @nextDisabled">
                <button class="page-link" disabled="@(!Cards.Pages.HasNext)"
                    @onclick="() => FilterCards(Cards.Pages.Current + 1)">
                    Next
                </button>
            </li>

        </ul>
    </nav>
}


@code {

    [Parameter]
    public bool IsSignedIn { get; set; } = false;

    [Parameter]
    public int PageSize { get; set; }

    private PagedList<Card> Cards { get; set; }


    private bool _isBusy;
    private IReadOnlyList<Card> _dbCards;
    private IReadOnlyDictionary<string, int> _cardAmounts;

    private readonly HashSet<string> _colorFilter = new();
    private string _searchName;

    private string _orderProperty;
    private bool _isReversed;


    private int CardTotal(Card card) =>
        _cardAmounts.GetValueOrDefault(card.Id);


    private string BoldIfActive<T>(Expression<Func<Card, T>> property) =>
        _orderProperty == null || MemberName(property) != _orderProperty
            ? ""
            : "font-weight-bold";


    private string MemberName<T>(Expression<Func<Card, T>> property) =>
        (property.Body as MemberExpression)?.Member.Name;



    protected override async Task OnInitializedAsync()
    {
        await FetchCardsAsync();
        await base.OnInitializedAsync();
    }


    protected override void OnParametersSet()
    {
        _colorFilter.Clear();
        _orderProperty = null;
        _searchName = string.Empty;

        FilterCards();

        base.OnParametersSet();
    }


    private async Task FetchCardsAsync()
    {
        if (_isBusy)
        {
            return;
        }

        _isBusy = true;
        try
        {
            await using var dbContext = DbFactory.CreateDbContext();

            _dbCards = await dbContext.Cards
                .Include(c => c.Colors)
                .ToListAsync(); // unbounded, keep eye on

            _cardAmounts = await dbContext.Amounts
                .GroupBy( ca => ca.CardId,
                    (CardId, cas) =>
                        new { CardId, Total = cas.Sum(ca => ca.Amount) })

                .ToDictionaryAsync(ct => ct.CardId, ct => ct.Total);
        }
        finally
        {
            _isBusy = false;
        }
    }


    private void FilterCards(int pageIndex = 0)
    {
        if (pageIndex < 0 
            || Cards?.Pages.Total is int totalPages 
                && totalPages > 0 
                && pageIndex >= totalPages)
        {
            return;
        }

        Cards = CardsFiltered().ToPagedList(PageSize, pageIndex);
    }


    private IEnumerable<Card> CardsFiltered()
    {
        var cards = _dbCards.AsEnumerable();

        if (!string.IsNullOrWhiteSpace(_searchName))
        {
            cards = cards.Where(c => 
                c.Name.ToLower().Contains(_searchName));
        }

        if (_colorFilter.Any())
        {
            cards = cards.Where(c =>
                c.Colors.Any(color => 
                    _colorFilter.Contains(color.Name.ToLower()) ));
        }

        return CardsOrdered(cards);
    }


    private IOrderedEnumerable<Card> CardsOrdered(IEnumerable<Card> cards)
    {
        var isAscending = _orderProperty switch
        {
            nameof(Card.ManaCost) => true,
            nameof(Card.SetName) => true,
            nameof(Card.Rarity) => false,
            nameof(Card.Amounts) => false,
            _ => true
        };

        IOrderedEnumerable<Card> PrimaryOrder<T>(Func<Card, T> property) =>
            isAscending ^ _isReversed
                ? cards.OrderBy(property)
                : cards.OrderByDescending(property);

        return _orderProperty switch
        {
            nameof(Card.ManaCost) => 
                PrimaryOrder(c => c.Cmc)
                    .ThenBy(c => c.Name)
                    .ThenBy(c => c.SetName),

            nameof(Card.SetName) =>
                PrimaryOrder(c => c.SetName)
                    .ThenBy(c => c.Name),

            nameof(Card.Rarity) => 
                PrimaryOrder(c => c.Rarity)
                    .ThenBy(c => c.Name)
                    .ThenBy(c => c.SetName),

            nameof(Card.Amounts) => 
                // PrimaryOrder(c => c.Amounts.Sum(ca => ca.Amount))
                PrimaryOrder(c => _cardAmounts.GetValueOrDefault(c.Id))
                    .ThenBy(c => c.Name)
                    .ThenBy(c => c.SetName),

            _ => PrimaryOrder(c => c.Name)
                    .ThenBy(c => c.SetName)
        };
    }



    private void FilterColor(string color)
    {
        if (_colorFilter.Contains(color))
        {
            _colorFilter.Remove(color);
        }
        else
        {
            _colorFilter.Add(color);
        }

        FilterCards();
    }


    private void SearchName(ChangeEventArgs eventArgs)
    {
        _searchName = eventArgs.Value?.ToString();
        
        FilterCards();
    }


    private void ReorderCards<T>(Expression<Func<Card, T>> property)
    {
        var newOrder = MemberName(property);
        var oldOrder = _orderProperty;

        if (newOrder is null)
        {
            return;
        }

        _isReversed = newOrder == oldOrder && !_isReversed;
        _orderProperty = newOrder;

        FilterCards();
    }


    private async Task RefreshCardsAsync()
    {
        await FetchCardsAsync();

        // keep current filters
        FilterCards();
    }
}