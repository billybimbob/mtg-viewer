@using System
@using System.Linq
@using System.Linq.Expressions
@using System.Collections.Immutable

@namespace MTGViewer.Components
@implements IDisposable

@inject IDbContextFactory<CardDbContext> DbFactory
@inject SymbolFormatter MtgSymbols
@inject ILogger<Library> Logger


<h1>Card Collection</h1>

<div class="btn-group" role="group">
    @if (IsSignedIn)
    {
        <a class="btn btn-secondary" href="Cards/Create" role="button">Add Card</a>
    }
</div>

<div class="form-row align-items-center my-3">
    <div class="col-3">
        <input class="form-control" 
            placeholder="Card Name" 
            disabled="@_isBusy"
            @onchange="SearchNameAsync" />
    </div>

    <div class="col-auto btn-group" role="group" aria-label="Color Buttons">
        @foreach (var (symbol, color) in Color.Symbols)
        {
            var active = _colorFilter.Contains(color) ? "active" : "";

            <button title="@color filter"
                type="button"
                class="btn btn-outline-secondary border-0 rounded @active"
                disabled="@_isBusy"
                @onclick="() => FilterColorAsync(color)">

                <i class="ms ms-@symbol.ToLower() ms-cost"></i>
            </button>
        }
    </div>
</div>

<table class="table">
    <thead>
        <tr>
            <th scope="col"
                title="Order By Name"
                @onclick="() => ReorderCardsAsync(c => c.Name)" 
                class="@HeaderClass(c => c.Name)">
                @Entities.DisplayName((Card c) => c.Name)
            </th>

            <th scope="col" 
                title="Order By Cmc"
                @onclick="() => ReorderCardsAsync(c => c.ManaCost)" 
                class="@HeaderClass(c => c.ManaCost)">
                @Entities.DisplayName((Card c) => c.ManaCost)
            </th>

            <th scope="col"
                title="Order By Set Name"
                @onclick="() => ReorderCardsAsync(c => c.SetName)" 
                class="@HeaderClass(c => c.SetName)">
                @Entities.DisplayName((Card c) => c.SetName)
            </th>

            <th scope="col"
                title="Order By Rarity"
                @onclick="() => ReorderCardsAsync(c => c.Rarity)" 
                class="@HeaderClass(c => c.Rarity)">
                @Entities.DisplayName((Card c) => c.Rarity)
            </th>

            <th scope="col" 
                title="Order By Number of Copies"
                @onclick="() => ReorderCardsAsync(c => c.Amounts)" 
                class="@HeaderClass(c => c.Amounts)">
                Total Copies
            </th>

            <th scope="col"></th>
        </tr>
    </thead>

    <tbody>
        @foreach (var card in Cards)
        {
            <tr>
                <td> <HoverCard Card="@((CardPreview)card)"/> </td>

                <td> @(MtgSymbols.Format(card.ManaCost).ToMarkupString()) </td>
                <td> @card.SetName </td>
                <td> @card.Rarity </td>
                <td> @CardTotal(card) </td>

                <td>
                    @if (IsSignedIn)
                    {
                        <a title="Suggest @card.Name"
                           href="/Transfers/Suggest/@card.Id"
                           class="btn btn-secondary"
                           role="button">
                           Suggest </a>
                    }
                </td>
            </tr>
        }
    </tbody>
</table>

<Pagination Pages="Cards.Pages" PageSelected="FetchCardsAsync"></Pagination>


@code {

    [Parameter]
    public bool IsSignedIn { get; set; } = false;

    [Parameter]
    public int PageSize { get; set; }

    private PagedList<Card> Cards { get; set; } = PagedList<Card>.Empty;


    private bool _isBusy;
    private readonly CancellationTokenSource _cancel = new();

    private readonly HashSet<Card> _dbCards = new();
    private readonly Dictionary<string, int> _cardAmounts = new();

    private readonly HashSet<string> _colorFilter = new(StringComparer.CurrentCultureIgnoreCase);
    private string? _searchName;

    private string? _orderProperty;
    private bool _isReversed;


    private int CardTotal(Card card) =>
        _cardAmounts.GetValueOrDefault(card.Id);


    private string HeaderClass<T>(Expression<Func<Card, T>> property)
    {
        if (_isBusy)
        {
            return string.Empty;
        }
        else if (_orderProperty == null || MemberName(property) != _orderProperty)
        {
            return "clickable btn-link";
        }
        else
        {
            return "clickable btn-link font-weight-bold";
        }
    }


    private string? MemberName<T>(Expression<Func<Card, T>> property) =>
        (property.Body as MemberExpression)?.Member.Name;



    protected override Task OnParametersSetAsync()
    {
        _colorFilter.Clear();
        _orderProperty = null;
        _searchName = string.Empty;

        return FetchCardsAsync();
    }


    public void Dispose()
    {
        _cancel.Cancel();
        _cancel.Dispose();
    }



    #region Fetch

    private async Task FetchCardsAsync(int pageIndex = 0)
    {
        if (_isBusy
            || PageSize <= 0
            || pageIndex < 0 
            || Cards.Pages.Total > 0 && pageIndex >= Cards.Pages.Total)
        {
            return;
        }

        _isBusy = true;
        _orderProperty ??= nameof(Card.Name);

        var cancelToken = _cancel.Token;

        try
        {
            await using var dbContext = await DbFactory.CreateDbContextAsync(cancelToken);

            dbContext.AttachRange(_dbCards); // reuse prior card objs

            Cards = await GetFilteredCardsAsync(dbContext, pageIndex, cancelToken);

            var cardAmounts = await GetCardAmountsAsync(dbContext, Cards, cancelToken);

            _dbCards.UnionWith(Cards);

            foreach ((string cardId, int total) in cardAmounts)
            {
                _cardAmounts[cardId] = total;
            }
        }
        catch (OperationCanceledException ex)
        {
            Logger.LogError(ex.ToString());
        }
        finally
        {
            _isBusy = false;
        }
    }


    private Task<PagedList<Card>> GetFilteredCardsAsync(
        CardDbContext dbContext,
        int pageIndex,
        CancellationToken cancel)
    {
        var cards = dbContext.Cards.AsQueryable();

        if (!string.IsNullOrWhiteSpace(_searchName))
        {
            cards = cards.Where(c => 
                c.Name.ToLower().Contains(_searchName));
        }

        if (_colorFilter.Any())
        {
            cards = cards.Where(c =>
                c.Colors.Any(cl => _colorFilter.Contains(cl.Name)));
        }

        bool dbEval = _orderProperty switch
        {
            nameof(Card.Rarity) => false,
            _ => true
        };

        return dbEval
            ? CardsOrdered(cards)
                .ToPagedListAsync(PageSize, pageIndex, cancel)

            : CardsOrdered(cards.AsAsyncEnumerable())
                // paging is kind of pointless since server eval is unbounded
                .ToPagedListAsync(PageSize, pageIndex, cancel);
    }


    private IQueryable<Card> CardsOrdered(IQueryable<Card> cards)
    {
        IOrderedQueryable<Card> PrimaryOrder<T>(
            Expression<Func<Card, T>> property)
        {
            return IsAscending(_orderProperty) ^ _isReversed
                ? cards.OrderBy(property)
                : cards.OrderByDescending(property);
        }

        return _orderProperty switch
        {
            nameof(Card.ManaCost) => 
                PrimaryOrder(c => c.Cmc)
                    .ThenBy(c => c.Name)
                    .ThenBy(c => c.SetName),

            nameof(Card.SetName) =>
                PrimaryOrder(c => c.SetName)
                    .ThenBy(c => c.Name),

            nameof(Card.Amounts) => 
                PrimaryOrder(c => c.Amounts.Sum(a => a.NumCopies))
                    .ThenBy(c => c.Name)
                    .ThenBy(c => c.SetName),

            _ => PrimaryOrder(c => c.Name)
                    .ThenBy(c => c.SetName)
        };
    }


    private IAsyncEnumerable<Card> CardsOrdered(IAsyncEnumerable<Card> cards)
    {
        IOrderedAsyncEnumerable<Card> PrimaryOrder<T>(
            Func<Card, T> property, IComparer<T> comparer)
        {
            return IsAscending(_orderProperty) ^ _isReversed
                ? cards.OrderBy(property, comparer)
                : cards.OrderByDescending(property, comparer);
        }

        // custom order comparers are not supported in ef core
        return _orderProperty switch
        {
            nameof(Card.Rarity) or _ => 
                PrimaryOrder(c => c.Rarity, new RarityComparer())
                    .ThenBy(c => c.Name)
                    .ThenBy(c => c.SetName),
        };
    }


    private static bool IsAscending(string? property) => property switch
    {
        nameof(Card.ManaCost) => true,
        nameof(Card.SetName) => true,
        nameof(Card.Rarity) => false,
        nameof(Card.Amounts) => false,
        _ => true
    };


    private Task<Dictionary<string, int>> GetCardAmountsAsync(
        CardDbContext dbContext, 
        IEnumerable<Card> cards,
        CancellationToken cancel)
    {
        var cardIds = Cards
            .Select(c => c.Id)
            .ToArray();

        return dbContext.Amounts
            .Where(a => cardIds.Contains(a.CardId))
            .GroupBy(a => a.CardId,
                (CardId, cas) =>
                    new { CardId, Total = cas.Sum(ca => ca.NumCopies) })
            .ToDictionaryAsync(
                ct => ct.CardId, ct => ct.Total, cancel);
    }

    #endregion



    private Task FilterColorAsync(string color)
    {
        if (_isBusy)
        {
            return Task.CompletedTask;
        }

        if (_colorFilter.Contains(color))
        {
            _colorFilter.Remove(color);
        }
        else
        {
            _colorFilter.Add(color);
        }

        return FetchCardsAsync();
    }


    private Task SearchNameAsync(ChangeEventArgs eventArgs)
    {
        if (_isBusy)
        {
            return Task.CompletedTask;
        }

        _searchName = eventArgs.Value?.ToString();
        
        return FetchCardsAsync();
    }


    private Task ReorderCardsAsync<T>(Expression<Func<Card, T>> property)
    {
        if (_isBusy || MemberName(property) is not string newOrder)
        {
            return Task.CompletedTask;
        }

        string? oldOrder = _orderProperty;

        _isReversed = newOrder == oldOrder && !_isReversed;
        _orderProperty = newOrder;

        return FetchCardsAsync();
    }
}