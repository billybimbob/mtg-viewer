@using MTGViewer.Data
@using MTGViewer.Data.Concurrency

@namespace MTGViewer.Components
@implements IAsyncDisposable

@inject ILogger<Trader> Log
@inject IDbContextFactory<CardDbContext> DbFactory


<h1>@_receiverDeck.Name Trader</h1>

<select class="form-control" @bind="_destinationId">
    @foreach (var location in GetDestinationOptions())
    {
        <option value="@location.Id">@location.Name</option>
    }
</select>

<button title="Save Deck"
        type="button"
        class="btn btn-secondary mb-3"
        disabled="@HasNoChanges()"
        @onclick="CommitChangesAsync">
    Save Changes
</button>

<SavePrompt @bind-Result="_result">
    <SuccessMessage>
        Save was succesful, and trades have been updated
    </SuccessMessage>
    <ErrorMessage>
        <p>There are conflicts while trying to save, and values have been updated. </p>
        <hr>
        <p>Save again to confirm</p>
    </ErrorMessage>
</SavePrompt>

<div class="container">
    <div class="row">

        <div class="col">
            @if (Destination == null)
            {
                <h2>@_proposer.Name</h2>
            }
            else
            {
                <h2>@_proposer.Name (@Destination.Name)</h2>
            }
            <table class="table">
                <thead>
                    <tr>
                        <th>Card Name</th>
                        <th>Mana Cost</th>
                        <th>Amount Available</th>
                        <th></th>
                    </tr>
                </thead>
                <tbody>
                    @foreach (var (cardAmount, amount) in GetMergedDestination())
                    {
                        var card = cardAmount.Card;
                        <tr>
                            <td class="fw-bold">@card.Name</td>
                            <td>
                                @foreach (var cost in card.GetManaSymbols())
                                {
                                    <span class="m-1 ms ms-@cost ms-cost"></span>
                                }
                            </td>
                            <td>@amount</td>
                            <td>
                                <button title="Offer @card.Name"
                                        type="button"
                                        class="btn btn-outline-secondary border-0 rounded"
                                        disabled="@(amount == 0)"
                                        @onclick="() => FromProposer(cardAmount)">
                                    Offer Card
                                </button>
                            </td>
                        </tr>
                    }
                </tbody>
            </table>
        </div>

        <div class="col">
            <h2>@_receiverDeck.Owner.Name (@_receiverDeck.Name)</h2>
            <table class="table">
                <thead>
                    <tr>
                        <th>Card Name</th>
                        <th>Mana Cost</th>
                        <th>Amount Available</th>
                        <th></th>
                    </tr>
                </thead>
                <tbody>
                    @foreach (var (cardAmount, amount) in GetMergedDeck())
                    {
                        var card = cardAmount.Card;
                        <tr>
                            <td class="fw-bold">@card.Name</td>
                            <td>
                                @foreach (var cost in card.GetManaSymbols())
                                {
                                    <span class="m-1 ms ms-@cost ms-cost"></span>
                                }
                            </td>
                            <td>@amount</td>
                            <td>
                                <button title="Take @card.Name"
                                        type="button"
                                        class="btn btn-outline-secondary border-0 rounded"
                                        disabled="@(amount == 0 || Destination == null)"
                                        @onclick="() => FromReceiver(cardAmount)">
                                    Take Card
                                </button>
                            </td>
                        </tr>
                    }
                </tbody>
            </table>
        </div>

    </div>
    <div class="row">

        <div class="col">
            <h2>From @_proposer.Name</h2>
            <table class="table">
                <thead>
                    <tr>
                        <th>Card Name</th>
                        <th>Mana Cost</th>
                        <th>From</th>
                        <th>Amount</th>
                        <th></th>
                    </tr>
                </thead>
                    @foreach (var trade in GetToDeckTrades())
                    {
                        <tr>
                            <td class="fw-bold">@trade.Card.Name</td>
                            <td>
                                @foreach (var cost in trade.Card.GetManaSymbols())
                                {
                                    <span class="m-1 ms ms-@cost ms-cost"></span>
                                }
                            </td>
                            <td>@trade.From.Name</td>
                            <td>@trade.Amount</td>
                            <td>
                                <button title="Return @trade.Card.Name"
                                        type="button"
                                        disabled="@(Destination == null)"
                                        class="btn btn-outline-secondary border-0 rounded"
                                        @onclick="() => ReturnCard(trade)">
                                    Return
                                </button>
                            </td>
                        </tr>
                    }
                <tbody>
                </tbody>
            </table>
        </div>

        <div class="col">
            <h2>From @_receiverDeck.Owner.Name</h2>
            <table class="table">
                <thead>
                    <tr>
                        <th>Card Name</th>
                        <th>Mana Cost</th>
                        <th>To</th>
                        <th>Amount</th>
                        <th></th>
                    </tr>
                </thead>
                <tbody>
                    @foreach (var trade in GetFromDeckTrades())
                    {
                        <tr>
                            <td class="fw-bold">@trade.Card.Name</td>
                            <td>
                                @foreach (var cost in trade.Card.GetManaSymbols())
                                {
                                    <span class="m-1 ms ms-@cost ms-cost"></span>
                                }
                            </td>
                            <td>@trade.To.Name</td>
                            <td>@trade.Amount</td>
                            <td>
                                <button title="Return @trade.Card.Name"
                                        type="button"
                                        class="btn btn-outline-secondary border-0 rounded"
                                        @onclick="() => ReturnCard(trade)">
                                    Return
                                </button>
                            </td>
                        </tr>
                    }
                </tbody>
            </table>
        </div>

    </div>
</div>


@code {

    [Parameter]
    public int DeckId { get; set; }

    [Parameter]
    public string ProposerId { get; set; }


    private record TradeKey(Card Card, Deck To, Deck From) { }

    private record MergedAmount(CardAmount CardAmount, int AmountWithTrade) { }


    private bool _busy;
    private SaveResult _result;
    private CardDbContext _dbContext;

    private UserRef _proposer;
    private IReadOnlyList<CardAmount> _proposerOptions;

    private Deck _receiverDeck;
    private IDictionary<TradeKey, Trade> _currentOffers;

    private int _destinationId;
    private IReadOnlyDictionary<int, Deck> _destinationOptions;

    private Deck Destination =>
        _destinationOptions.TryGetValue(_destinationId, out var dest) ? dest : null;



    protected override void OnInitialized()
    {
        _dbContext = DbFactory.CreateDbContext();
        base.OnInitialized();
    }


    protected override async Task OnParametersSetAsync()
    {
        if (_busy)
        {
            return;
        }

        _busy = true;
        try
        {
            await InitFieldsFromParameters();
        }
        finally
        {
            _busy = false;
        }

        await base.OnParametersSetAsync();
    }


    private async ValueTask InitFieldsFromParameters()
    {
        _receiverDeck = await _dbContext.Decks
            .Include(l => l.Owner)
            .Include(l => l.Cards)
                .ThenInclude(ca => ca.Card)
            .SingleAsync(l => l.Id == DeckId);

        _proposer = await _dbContext.Users.FindAsync(ProposerId);

        _proposerOptions = await _dbContext.Amounts
            .Where(ca => !ca.IsRequest
                && ca.Location is Deck
                && (ca.Location as Deck).OwnerId == _proposer.Id)
            .Include(ca => ca.Card)
            .Include(ca => ca.Location)
            .OrderBy(ca => ca.Card.Name)
            .ToListAsync();

        _currentOffers = await _dbContext.Trades
            .Where(TradeFilter.Involves(_proposer.Id, DeckId))
            .Include(t => t.Card)
            .Include(t => t.To)
            .Include(t => t.From)
            .ToDictionaryAsync(t => new TradeKey(t.Card, t.To, t.From));

        _destinationOptions = _proposerOptions
            .Select(ca => ca.Location as Deck)
            .Distinct()
            .ToDictionary(l => l.Id);

        _dbContext.Attach(_proposer);
    }


    public async ValueTask DisposeAsync()
    {
        if (_dbContext is not null)
        {
            await _dbContext.DisposeAsync();
        }
    }



    private bool HasNoChanges() =>
        !_dbContext.ChangeTracker.HasChanges();


    private IEnumerable<Location> GetDestinationOptions() =>
        _destinationOptions.Values.OrderBy(l => l.Name);


    private IEnumerable<Trade> GetToDeckTrades() =>
        _currentOffers.Values
            .Where(t => t.ToId == DeckId && t.Amount > 0);


    private IEnumerable<Trade> GetFromDeckTrades() =>
        _currentOffers.Values
            .Where(t => t.From.Id == DeckId && t.Amount > 0);



    private IEnumerable<MergedAmount> GetMergedDeck()
    {
        var mergedAmounts = _receiverDeck.Cards
            .ToDictionary(
                ca => (ca.CardId, ca.LocationId),
                ca => ca.Amount);

        foreach (var trade in _currentOffers.Values)
        {
            var key = (trade.CardId, trade.FromId);

            if (mergedAmounts.TryGetValue(key, out int amount))
            {
                mergedAmounts[key] = amount - trade.Amount;
            }
        }

        var orderedDeck = _receiverDeck.Cards.OrderBy(ca => ca.Card.Name);

        foreach (var cardAmount in orderedDeck)
        {
            var key = (cardAmount.CardId, cardAmount.LocationId);

            yield return new MergedAmount(
                cardAmount,
                mergedAmounts[key]);
        }
    }


    private IEnumerable<MergedAmount> GetMergedDestination()
    {
        var optionsFromSelect = _proposerOptions
            .Where(ca => ca.Location.Id == _destinationId);

        var mergedAmounts = optionsFromSelect
            .ToDictionary(
                ca => (ca.CardId, ca.LocationId),
                ca => ca.Amount);

        foreach (var trade in _currentOffers.Values)
        {
            var key = (trade.CardId, trade.FromId);

            if (mergedAmounts.TryGetValue(key, out int amount))
            {
                mergedAmounts[key] = amount - trade.Amount;
            }
        }

        var orderedOptions = optionsFromSelect.OrderBy(ca => ca.Card.Name);

        foreach (var cardAmount in orderedOptions)
        {
            var key = (cardAmount.CardId, cardAmount.LocationId);

            yield return new MergedAmount(
                cardAmount, 
                mergedAmounts[key]);
        }
    }



    private void FromProposer(CardAmount proposeSource)
    {
        var fromDeck = proposeSource.Location as Deck;

        if (proposeSource.Amount == 0 || fromDeck is null)
        {
            return;
        }

        Trade trade;

        var reverseOffer = new TradeKey(proposeSource.Card, To: fromDeck, From: _receiverDeck);

        if (_currentOffers.TryGetValue(reverseOffer, out trade) && trade.Amount > 0)
        {
            ReturnCard(trade);
            return;
        }

        var offer = new TradeKey(proposeSource.Card, To: _receiverDeck, From: fromDeck);

        if (!_currentOffers.TryGetValue(offer, out trade))
        {
            trade = new Trade
            {
                Card = proposeSource.Card,
                To = _receiverDeck,
                From = fromDeck,
                Proposer = fromDeck.Owner,
                Receiver = _receiverDeck.Owner,
                Amount = 0
            };

            _currentOffers.Add(offer, trade);
            _dbContext.Add(trade);
        }

        if (proposeSource.Amount - trade.Amount <= 0)
        {
            Log.LogError($"cannot offer and more for {offer.Card.Name}");
            return;
        }

        trade.Amount += 1;
    }


    private void FromReceiver(CardAmount receiverSource)
    {
        if (Destination == null)
        {
            return;
        }

        var fromDeck = receiverSource.Location as Deck;

        if (receiverSource.Amount == 0 || fromDeck is null)
        {
            return;
        }

        Trade trade;

        var reverseTake = new TradeKey(receiverSource.Card, To: fromDeck, From: Destination);

        if (_currentOffers.TryGetValue(reverseTake, out trade) && trade.Amount > 0)
        {
            ReturnCard(trade);
            return;
        }

        var take = new TradeKey(receiverSource.Card, To: Destination, From: fromDeck);

        if (!_currentOffers.TryGetValue(take, out trade))
        {
            trade = new Trade
            {
                Card = receiverSource.Card,
                To = Destination,
                From = fromDeck,
                Proposer = Destination.Owner,
                Receiver = fromDeck.Owner,
                Amount = 0
            };

            _currentOffers.Add(take, trade);
            _dbContext.Add(trade);
        }

        if (receiverSource.Amount - trade.Amount <= 0)
        {
            Log.LogError($"cannot take anymore for {take.Card.Name}");
            return;
        }

        trade.Amount += 1;
    }


    private void ReturnCard(Trade trade)
    {
        if (trade.Amount == 0)
        {
            return;
        }

        trade.Amount -= 1;
    }


    private async Task CommitChangesAsync()
    {
        if (_busy)
        {
            return;
        }

        _busy = true;
        PrepareChanges();

        try
        {
            await _dbContext.SaveChangesAsync();
            _result = SaveResult.Success;
        }
        catch (DbUpdateConcurrencyException ex)
        {
            _result = SaveResult.Error;
            await ResolveConcurrencyIssuesAsync(ex);
        }
        catch (DbUpdateException ex)
        {
            _result = SaveResult.Error;
            Log.LogInformation($"got error {ex}");
        }
        finally
        {
            _busy = false;
        }
    }


    private void PrepareChanges()
    {
        foreach(var trade in _currentOffers.Values)
        {
            if (_dbContext.Entry(trade).State == EntityState.Detached)
            {
                _dbContext.Attach(trade);
            }

            if (trade.Amount == 0)
            {
                _dbContext.Remove(trade);
                continue;
            }
        }
    }


    private async Task ResolveConcurrencyIssuesAsync(DbUpdateConcurrencyException ex)
    {
        foreach(var entry in ex.Entries)
        {
            switch(entry.Entity)
            {
                case CardAmount cardAmount:
                    await MergeCardAmount(cardAmount);
                    break;

                case Trade trade:
                    await MergeTrade(trade);
                    break;

                default:
                    break;
            }
        }
    }


    private async Task MergeCardAmount(CardAmount cardAmount)
    {
        var dbAmount = await _dbContext.Entry(cardAmount)
            .GetDatabaseValuesAsync();

        if (dbAmount == null)
        {
            _dbContext.Add(cardAmount);
        }
        else
        {
            var amount = _dbContext.Entry(cardAmount)
                .Property(ca => ca.Amount)
                .Metadata;

            cardAmount.Amount = dbAmount.GetValue<int>(amount);
            _dbContext.MatchToken(cardAmount, dbAmount);
        }
    }


    private async Task MergeTrade(Trade trade)
    {
        var dbTrade = await _dbContext.Entry(trade)
            .GetDatabaseValuesAsync();

        if (dbTrade == null)
        {
            _dbContext.Add(trade);
        }
        else
        {
            _dbContext.MatchToken(trade, dbTrade);
        }
    }
}