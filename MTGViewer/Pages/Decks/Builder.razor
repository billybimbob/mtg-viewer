@page "/Decks/Builder/{DeckId:int?}"
@attribute [Authorize]
@inherits OwningComponentBase

@using Microsoft.AspNetCore.Identity
@using Microsoft.Extensions.DependencyInjection

@using MTGViewer.Areas.Identity.Data
@using MTGViewer.Data.Concurrency
@using MTGViewer.Data.Internal

@inject FixedCache Cache
@inject IDbContextFactory<CardDbContext> DbFactory
@inject SymbolFormatter MtgSymbols
@inject CardText CardText

@inject PageSizes PageSizes
@inject NavigationManager Nav
@inject ILogger<Builder> Logger


<PageTitle> @Title </PageTitle>

@if (_deckContext is not null)
{
    <EditForm EditContext="@_deckContext.EditContext">
        <div class="row">
            <div class="col col-md-6">
            <InputText 
                class="form-control form-control-lg mb-3"
                @bind-Value="_deckContext.Deck.Name" 
                DisplayName="Deck Name"/>

                <DataAnnotationsValidator />
                <ValidationSummary />
            </div>
        </div>
    </EditForm>
}
else
{
    <h1> Deck Builder </h1>
}

<div class="mb-3">
    <button title="Save Deck" type="button"
        class="btn btn-secondary" 
        disabled="@HasNoChanges"
        @onclick="CommitChangesAsync">
        Save Changes
    </button>
</div>

<div class="form-row align-items-center my-3">
    <div class="col-12 col-md-4">
        <input class="form-control" placeholder="Card Name" @onchange="SearchName" />
    </div>

    <div class="col-auto btn-group pt-2 pt-md-0" role="group" aria-label="Color Buttons">
        @foreach (var (symbol, color) in Color.Symbols)
        {
            <button title="@color filter" type="button"
                class="btn btn-outline-secondary border-0 rounded @ActiveColor(color)"
                @onclick="() => FilterColor(color)">

                <i class="ms ms-@symbol.ToLower() ms-cost"></i>
            </button>
        }
    </div>
</div>

<SavePrompt @bind-Result="_result">
    <SuccessMessage>
        Save was succesful, and values have been updated
    </SuccessMessage>
    <ErrorMessage>
        <p>There are conflicts while trying to save, and values have been updated. </p>
        <hr />
        <p>Save again to confirm</p>
    </ErrorMessage>
</SavePrompt>

<div class="row">
    <div class="col-12 col-lg-7">
        <h3>Treasury</h3>

        <div class="list-group list-group-flush mb-4">
            @foreach (var (card, available) in Treasury)
            {
                var wantTotal = card.Wants.Sum(w => w.NumCopies);

                <button type="button" title="Add @card.Name"
                    class="list-group-item list-group-item-action px-2"
                    @onclick="() => AddCardToDeck(card)">

                    <div class="row">
                        <div class="col-6"> 
                            <HoverCard Target="card"> 
                                <span class="btn-link">@card.Name</span>
                            </HoverCard>
                        </div>

                        <div class="col-4"> @MtgSymbols.Format(card.ManaCost).ToMarkupString() </div>
                        <div class="col-2"> @(available - Math.Min(wantTotal, available)) </div>
                    </div>
                </button>
            }

            @if (!Treasury.Any())
            {
                <div class="list-group-item disabled px-2" aria-disabled="true">
                    <div class="row">
                        <div class="col-6"> --- </div>
                        <div class="col-4"> --- </div>
                        <div class="col-2"> --- </div>
                    </div>
                </div>
            }
        </div>

        <Pagination Pages="TreasuryPages" PageSelected="ChangeTreasuryPage" />
    </div>

    <div class="col">
        <h3>@DeckName</h3>

        <div class="list-group list-group-flush mb-4">
            @foreach (var (card, group) in DeckCards)
            {
                <button type="button" title="Remove @card.Name"
                    class="list-group-item list-group-item-action px-2"
                    disabled="@(group.NumCopies <= 0)"
                    @onclick="() => RemoveCardFromDeck(card)">

                    <div class="row">
                        <div class="col-5">
                            <HoverCard Target="card"> 
                                <span class="btn-link">@card.Name</span>
                            </HoverCard>
                        </div>

                        <div class="col-4"> @MtgSymbols.Format(card.ManaCost).ToMarkupString() </div>

                        <div class="col-3">
                            <span title="@card.Name Held" class="badge badge-pill badge-primary"> 
                                @(group.Amount?.NumCopies ?? 0) </span>

                            <span title="@card.Name Returning" class="badge badge-pill badge-danger"> 
                                @(group.GiveBack?.NumCopies ?? 0) </span>

                            <span title="@card.Name Wanted" class="badge badge-pill badge-secondary">
                                @(group.Want?.NumCopies ?? 0) </span>
                        </div>
                    </div>
                </button>
            }

            @if (!DeckCards.Any())
            {
                <div class="list-group-item disabled px-2" aria-disabled="true">
                    <div class="row">
                        <div class="col-5"> --- </div>
                        <div class="col-4"> --- </div>
                        <div class="col-3">
                            <span class="badge badge-pill badge-primary"> 0 </span>
                            <span class="badge badge-pill badge-danger"> 0 </span>
                            <span class="badge badge-pill badge-secondary"> 0 </span>
                        </div>
                    </div>
                </div>
            }
        </div>

        <Pagination Pages="DeckPages" PageSelected="ChangeDeckPage" />
    </div>
</div>


@code {

    [CascadingParameter]
    public Task<AuthenticationState> AuthState { get; set; } = null!;

    [Parameter]
    public int DeckId { get; set; } = default;


    private bool _isBusy;
    private readonly CancellationTokenSource _cancel = new();

    private SaveResult _result;
    private CardDbContext? _dbContext;

    private IReadOnlyList<Card> _cards = Array.Empty<Card>();
    private readonly Dictionary<string, int> _boxAmounts = new();

    private DeckContext? _deckContext;

    private readonly TreasuryFilterContext _treasuryFilters = new();
    private PagedList<Card> _filteredCards = PagedList<Card>.Empty;


    private string DeckName =>
        _deckContext?.Deck.Name is string name
            && !string.IsNullOrWhiteSpace(name) 
            ? name
            : "New Deck";

    private string Title => $"{DeckName} - Builder";


    private string ActiveColor(string color) =>
        _treasuryFilters.PickedColors.Contains(color) ? "active" : string.Empty;

    private bool HasNoChanges =>
        !_dbContext?.ChangeTracker.HasChanges() ?? true;


    private IEnumerable<(Card, int amount)> Treasury =>
        _filteredCards
            .Select(c => (c, _boxAmounts.GetValueOrDefault(c.Id)));

    private Data.Pages TreasuryPages => _filteredCards.Pages;


    private IEnumerable<(string cardId, QuantityGroup group)> ActiveDeck =>
        _deckContext
            ?.Groups
            ?.Where(kv => kv.Value.Total > 0)
            .Select(kv => (kv.Key, kv.Value))
            ?? Enumerable.Empty<(string, QuantityGroup)>();


    private IEnumerable<(Card, QuantityGroup)> DeckCards
    {
        get
        {
            int pageIndex = _deckContext?.PageIndex ?? 0;
            int pageSize = _deckContext?.PageSize ?? _treasuryFilters.PageSize;

            return _cards
                .Join( ActiveDeck,
                    c => c.Id,
                    cg => cg.cardId,
                    (card, cg) => (card, cg.group))
                .Skip(pageIndex * pageSize)
                .Take(pageSize);
        }
    }

    private Data.Pages DeckPages =>
        new Data.Pages(
            _deckContext?.PageIndex ?? 0, 
            ActiveDeck.Count(), 
            _deckContext?.PageSize ?? _treasuryFilters.PageSize);



    protected override async Task OnInitializedAsync()
    {
        if (_isBusy)
        {
            return;
        }

        _isBusy = true;

        try
        {
            var cancelToken = _cancel.Token;

            _treasuryFilters.PageSize = PageSizes.GetComponentSize<Builder>();

            _dbContext = await DbFactory.CreateDbContextAsync(cancelToken);

            _cards = await Cache
                .GetOrCreateAsync(nameof(_cards), () =>
                    CardsAsync(_dbContext, cancelToken));

            var boxAmounts = await Cache
                .GetOrCreateAsync(nameof(_boxAmounts), () =>
                    BoxAmountsAsync(_dbContext, cancelToken));

            foreach ((string cardId, int amount) in boxAmounts)
            {
                _boxAmounts[cardId] = amount;
            }

            ApplyFilters();
        }
        catch (OperationCanceledException ex)
        {
            Logger.LogError(ex.ToString());
        }
        finally
        {
            _isBusy = false;
        }
    }


    private static Task<List<Card>> CardsAsync(
        CardDbContext dbContext, CancellationToken cancel)
    {
        // split query since Card model has many props that will dup
        // unbounded, keep eye on

        return dbContext.Cards
            .Include(c => c.Colors)
            .OrderBy(c => c.Name)
                .ThenBy(c => c.SetName)
            .AsSplitQuery()
            .ToListAsync(cancel);
    }


    private static Task<Dictionary<string, int>> BoxAmountsAsync(
        CardDbContext dbContext, CancellationToken cancel)
    {
        return dbContext.Amounts
            .Where(ca => ca.Location is Box)
            .GroupBy(ca => ca.CardId,
                (CardId, cas) => 
                    new { CardId, Total = cas.Sum(ca => ca.NumCopies) })
            .ToDictionaryAsync(
                ct => ct.CardId, ct => ct.Total, cancel);
    }


    protected override async Task OnParametersSetAsync()
    {
        if (_isBusy || _dbContext is null)
        {
            return;
        }

        _isBusy = true;

        try
        {
            var cancelToken = _cancel.Token;
            var userId = await GetUserIdAsync();

            if (userId is null)
            {
                return;
            }

            var deckResult = DeckId == default
                ? await CreateDeckAsync(_dbContext, userId, cancelToken)
                : await FetchDeckOrRedirectAsync(_dbContext, userId, cancelToken);

            if (deckResult is null)
            {
                return;
            }

            _deckContext = new(deckResult, _treasuryFilters.PageSize);
        }

        catch (DbUpdateException ex)
        {
            Logger.LogError(ex.ToString());
        }
        catch (OperationCanceledException ex)
        {
            Logger.LogError(ex.ToString());
        }
        catch (NavigationException ex)
        {
            Logger.LogWarning(ex.ToString());
        }
        finally
        {
            _isBusy = false;
        }
    }


    private async Task<string?> GetUserIdAsync()
    {
        if (AuthState is null)
        {
            return null;
        }

        var userManager = ScopedServices.GetRequiredService<UserManager<CardUser>>();
        var authState = await AuthState;

        return userManager.GetUserId(authState.User);
    }


    private async Task<Deck?> FetchDeckOrRedirectAsync(
        CardDbContext dbContext, string userId, CancellationToken cancel)
    {
        var deck = await Cache
            .GetOrCreateAsync($"deck{DeckId}{userId}", GetDeckAsync);

        if (deck is null || deck.OwnerId != userId)
        {
            Nav.NavigateTo("/Decks", true);

            return null;
        }

        if (deck.TradesTo.Any())
        {
            Nav.NavigateTo("/Decks/Viewer", true);

            return null;
        }

        return deck;

        Task<Deck?> GetDeckAsync() =>
            dbContext.Decks
                .Where(d => d.Id == DeckId && d.OwnerId == userId)

                .Include(d => d.Cards) // unbounded: keep eye on
                .Include(d => d.Wants) // unbounded: keep eye on
                .Include(d => d.GiveBacks) // unbounded: keep eye on

                .Include(d => d.TradesTo
                    .OrderBy(t => t.Id)
                    .Take(1))

                .AsSplitQuery()
                .SingleOrDefaultAsync(cancel);
    }


    private async Task<Deck> CreateDeckAsync(
        CardDbContext dbContext, string userId, CancellationToken cancel)
    {
        var user = await Cache
            .GetOrCreateAsync($"user{userId}", GetUserAsync);

        if (user == null)
        {
            throw new ArgumentException(nameof(userId));
        }

        var userDeckCount = await Cache
            .GetOrCreateAsync($"count{userId}", GetDeckCountAsync);

        var newLoc = new Deck
        {
            Name = $"Deck #{userDeckCount + 1}",
            Owner = user
        };

        dbContext.Decks.Attach(newLoc);

        return newLoc;

        Task<UserRef?> GetUserAsync() =>
            dbContext.Users
                .FindAsync(new []{ userId }, cancel)
                .AsTask();

        Task<int> GetDeckCountAsync() =>
            dbContext.Decks
                .Where(d => d.OwnerId == userId)
                .CountAsync(cancel);
    }


    protected override void Dispose(bool disposing)
    {
        if (!disposing)
        {
            return;
        }

        _cancel.Cancel();
        _cancel.Dispose();

        _dbContext?.Dispose();
    }


    private class DeckContext
    {
        public Deck Deck { get; }

        public EditContext EditContext { get; }

        public Dictionary<string, QuantityGroup> Groups { get; }

        public int PageSize { get; }

        public int PageIndex { get; set; }

        public DeckContext(Deck deck, int pageSize)
        {
            if (deck is null)
            {
                throw new ArgumentNullException(nameof(deck));
            }

            Deck = deck;

            EditContext = new(deck);

            Groups = QuantityGroup
                .FromDeck(deck)
                .ToDictionary(cg => cg.CardId);

            PageSize = pageSize;
        }
    }


    private class TreasuryFilterContext
    {
        public readonly HashSet<string> PickedColors = new(StringComparer.CurrentCultureIgnoreCase);

        public int PageSize { get; set; }

        public int PageIndex { get; set; }

        public string? SearchName { get; set; }
    }


    private void ApplyFilters()
    {
        const StringComparison ignoreCase = StringComparison.CurrentCultureIgnoreCase;

        var filter = _cards.AsEnumerable();
        string? searchName = _treasuryFilters.SearchName;

        if (!string.IsNullOrWhiteSpace(searchName))
        {
            filter = filter.Where(c => 
                c.Name.Contains(searchName, ignoreCase));
        }

        var pickedColors = _treasuryFilters.PickedColors;

        if (pickedColors.Any())
        {
            filter = filter.Where(c => 
                c.Colors.Any(cl => pickedColors.Contains(cl.Name) ));
        }

        int pageSize = _treasuryFilters.PageSize;
        int pageIndex = _treasuryFilters.PageIndex;

        _filteredCards = filter.ToPagedList(pageSize, pageIndex);
    }


    private void FilterColor(string color)
    {
        var pickedColors = _treasuryFilters.PickedColors;

        if (pickedColors.Contains(color))
        {
            pickedColors.Remove(color);
        }
        else
        {
            pickedColors.Add(color);
        }

        ApplyFilters();
    }


    private void SearchName(ChangeEventArgs eventArgs)
    {
        string? newSearch = eventArgs.Value?.ToString();

        if (newSearch == _treasuryFilters.SearchName)
        {
            return;
        }

        _treasuryFilters.SearchName = newSearch;
        
        ApplyFilters();
    }


    private void ChangeTreasuryPage(int pageIndex)
    {
        if (_treasuryFilters.PageIndex == pageIndex
            || pageIndex < 0
            || pageIndex >= TreasuryPages.Total)
        {
            return;
        }

        _treasuryFilters.PageIndex = pageIndex;

        ApplyFilters();
    }


    private void ChangeDeckPage(int pageIndex)
    {
        if (_deckContext is null 
            || _deckContext.PageIndex == pageIndex
            || pageIndex < 0
            || pageIndex >= DeckPages.Total)
        {
            return;
        }

        _deckContext.PageIndex = pageIndex;
    }


    private void AddCardToDeck(Card card)
    {
        if (_dbContext == null || _deckContext == null)
        {
            return;
        }

        _result = SaveResult.None;

        var groups = _deckContext.Groups;
        var deckGroup = groups.GetValueOrDefault(card.Id);

        if (deckGroup?.GiveBack?.NumCopies > 0)
        {
            deckGroup.GiveBack.NumCopies -= 1;
            return;
        }

        if (deckGroup is null && groups.Count >= PageSizes.Limit)
        {
            Logger.LogWarning("deck want failed since at limit");
            return;
        }

        if (deckGroup?.Want is null)
        {
            var wantAmount = new Want
            {
                Card = card,
                Location = _deckContext.Deck,
                NumCopies = 0,
            };

            _dbContext.Wants.Attach(wantAmount);

            if (deckGroup is null)
            {
                deckGroup = new QuantityGroup(wantAmount);
                groups.Add(card.Id, deckGroup);
            }
            else
            {
                deckGroup.Want = wantAmount;
            }
        }

        deckGroup.Want!.NumCopies += 1;
    }


    private void RemoveCardFromDeck(Card card)
    {
        if (_dbContext == null || _deckContext == null)
        {
            return;
        }

        _result = SaveResult.None;

        if (!_deckContext.Groups.TryGetValue(card.Id, out var deckGroup))
        {
            Logger.LogError($"card {card.Id} is not in the deck");
            return;
        }

        if (deckGroup.Want?.NumCopies > 0)
        {
            deckGroup.Want.NumCopies -= 1;
            return;
        }

        int actualRemain = (deckGroup.Amount?.NumCopies ?? 0)
            - (deckGroup.GiveBack?.NumCopies ?? 0);

        if (actualRemain == 0)
        {
            Logger.LogError($"there are no more of {card.Id} to remove");
            return;
        }

        if (deckGroup.GiveBack is null)
        {
            var returnAmount = new GiveBack
            {
                Card = deckGroup.Card,
                Location = _deckContext.Deck,
                NumCopies = 0
            };

            _dbContext.GiveBacks.Attach(returnAmount);
            deckGroup.GiveBack = returnAmount;
        }

        deckGroup.GiveBack.NumCopies += 1;
    }



    private async Task CommitChangesAsync()
    {
        if (_isBusy
            || _dbContext is null 
            || _deckContext is null)
        {
            return;
        }

        if (!_deckContext.EditContext.Validate())
        {
            return;
        }

        var cancelToken = _cancel.Token;
        var deck = _deckContext.Deck;
        var groups = _deckContext.Groups;

        _isBusy = true;

        try
        {
            PrepareChanges(_dbContext, deck);

            await _dbContext.SaveChangesAsync(cancelToken);

            if (deck.GiveBacks.Any() || deck.Wants.Any())
            {
                Nav.NavigateTo($"/Decks/Exchange/{deck.Id}", true);
            }
            else
            {
                _result = SaveResult.Success;
            }
        }
        catch (DbUpdateConcurrencyException ex)
        {
            _result = SaveResult.Error;

            await UpdateDeckAsync(_dbContext, deck, groups, ex, cancelToken);
        }
        catch (DbUpdateException ex)
        {
            Logger.LogError(ex.ToString());
        }
        catch (OperationCanceledException ex)
        {
            Logger.LogError(ex.ToString());
        }
        catch (NavigationException ex)
        {
            Logger.LogWarning(ex.ToString());
        }
        finally
        {
            _isBusy = false;
        }
    }


    private void PrepareChanges(CardDbContext dbContext, Deck deck)
    {
        foreach (var want in deck.Wants)
        {
            if (want.NumCopies == 0)
            {
                dbContext.Wants.Remove(want);
            }
            // detaches when saved after a remove
            else if (dbContext.Entry(want).State == EntityState.Detached)
            {
                dbContext.Wants.Attach(want);
            }
        }

        foreach (var giveBack in deck.GiveBacks)
        {
            if (giveBack.NumCopies == 0)
            {
                dbContext.GiveBacks.Remove(giveBack);
            }
            else if (dbContext.Entry(giveBack).State == EntityState.Detached)
            {
                dbContext.GiveBacks.Attach(giveBack);
            }
        }

        var deckEntry = dbContext.Entry(deck);

        if (deckEntry.State == EntityState.Unchanged)
        {
            deckEntry.State = EntityState.Modified;
        }

        deck.UpdateColors(CardText);
    }


    private async Task UpdateDeckAsync(
        CardDbContext dbContext,
        Deck localDeck,
        Dictionary<string, QuantityGroup> deckCards,
        DbUpdateConcurrencyException ex,
        CancellationToken cancel)
    {
        if (HasNoDeckConflicts(localDeck, deckCards.Keys, ex))
        {
            return;
        }

        if (cancel.IsCancellationRequested)
        {
            return;
        }

        Deck? dbDeck = null;

        try
        {
            dbDeck = await dbContext.Decks
                .Where(d => d.Id == DeckId)
                .Include(d => d.Cards) // unbounded: keep eye on
                .Include(d => d.Wants) // unbounded: keep eye on
                .Include(d => d.GiveBacks) // unbounded: keep eye on

                .AsSplitQuery()
                .AsNoTracking()
                .SingleOrDefaultAsync(cancel);
        }
        catch (OperationCanceledException)
        { }

        if (cancel.IsCancellationRequested)
        {
            return;
        }

        if (dbDeck == default)
        {
            dbContext.Decks.Attach(localDeck);
            return;
        }

        MergeDeckRemoves(dbContext, localDeck, dbDeck);
        TrackNewDeckCards(dbContext, deckCards, dbDeck);
        MergeDeckCardConflicts(dbContext, deckCards, dbDeck);

        CapDeletes(deckCards.Values);
        dbContext.MatchToken(localDeck, dbDeck);
    }


    private static bool HasNoDeckConflicts(
        Deck deck, 
        IEnumerable<string> deckIds,
        DbUpdateConcurrencyException ex)
    {
        var deckConflict = ex.Entries<Location>().SingleOrDefault();

        if (deckConflict is not null && deckConflict.Entity.Id == deck.Id)
        {
            return false;
        }

        var amountConflicts = ex.Entries<Amount>()
            .IntersectBy(deckIds, e => e.Entity.CardId);

        var wantConflicts = ex.Entries<Want>()
            .IntersectBy(deckIds, e => e.Entity.CardId);

        var giveConflicts = ex.Entries<GiveBack>()
            .IntersectBy(deckIds, e => e.Entity.CardId);

        return !amountConflicts.Any()
            && !wantConflicts.Any()
            && !giveConflicts.Any();
    }


    private static void MergeDeckRemoves(
        CardDbContext dbContext, Deck localDeck, Deck dbDeck)
    {
        var removedCards = RemovedFromDb(localDeck.Cards, dbDeck.Cards);

        foreach(var removedCard in removedCards)
        {
            removedCard.NumCopies = 0;
            dbContext.Amounts.Remove(removedCard);
        }

        var removedWants = RemovedFromDb(localDeck.Wants, dbDeck.Wants);

        foreach (var removedWant in removedWants)
        {
            if (dbContext.Entry(removedWant).State == EntityState.Unchanged)
            {
                removedWant.NumCopies = 0;
                dbContext.Wants.Remove(removedWant);
            }
            else
            {
                dbContext.Wants.Attach(removedWant);
            }
        }

        var removedGiveBacks = RemovedFromDb(localDeck.GiveBacks, dbDeck.GiveBacks);

        foreach (var removedGive in removedGiveBacks)
        {
            if (dbContext.Entry(removedGive).State == EntityState.Unchanged)
            {
                removedGive.NumCopies = 0;
                dbContext.GiveBacks.Remove(removedGive);
            }
            else
            {
                dbContext.GiveBacks.Attach(removedGive);
            }
        }
    }


    private static IEnumerable<TQuantity> RemovedFromDb<TQuantity>(
        IEnumerable<TQuantity> localQuantity, 
        IEnumerable<TQuantity> dbQuantity)
        where TQuantity : Quantity
    {
        return localQuantity
            .GroupJoin(dbQuantity,
                lq => (lq.CardId, lq.LocationId),
                db => (db.CardId, db.LocationId),
                (local, dbs) =>
                    (local, noDb: !dbs.Any()))
            .Where(ln => ln.noDb)
            .Select(ln => ln.local);
    }


    private void MergeDeckCardConflicts(
        CardDbContext dbContext,
        IReadOnlyDictionary<string, QuantityGroup> deckCards,
        Deck dbDeck)
    {
        MergeQuantityConflicts(dbContext, deckCards, dbDeck.Cards, group => group.Amount);

        MergeQuantityConflicts(dbContext, deckCards, dbDeck.Wants, group => group.Want);

        MergeQuantityConflicts(dbContext, deckCards, dbDeck.GiveBacks, group => group.GiveBack);
    }


    private void MergeQuantityConflicts<TQuantity>(
        CardDbContext dbContext, 
        IReadOnlyDictionary<string, QuantityGroup> deckCards,
        IEnumerable<TQuantity> dbQuantities, 
        Func<QuantityGroup, TQuantity?> quantity)
        where TQuantity : Quantity
    {
        foreach (var dbQuantity in dbQuantities)
        {
            if (!deckCards.TryGetValue(dbQuantity.CardId, out var localGroup))
            {
                continue;
            }

            var localQuantity = quantity(localGroup);

            if (localQuantity is null)
            {
                continue;
            }

            if (dbContext.Entry(localQuantity).State == EntityState.Unchanged)
            {
                localQuantity.NumCopies = dbQuantity.NumCopies;
            }

            dbContext.MatchToken(localQuantity, dbQuantity);
        }
    }


    private void TrackNewDeckCards(
        CardDbContext dbContext, IDictionary<string, QuantityGroup> deckCards, Deck dbDeck)
    {
        TrackNewQuantity(dbContext, deckCards, dbDeck.Cards, group => group.Amount);

        TrackNewQuantity(dbContext, deckCards, dbDeck.Wants, group => group.Want);

        TrackNewQuantity(dbContext, deckCards, dbDeck.GiveBacks, group => group.GiveBack);
    }


    private void TrackNewQuantity<TQuantity>(
        CardDbContext dbContext, 
        IDictionary<string, QuantityGroup> deckCards,
        IEnumerable<TQuantity> dbQuantities,
        Expression<Func<QuantityGroup, TQuantity?>> quantity)
        where TQuantity : Quantity
    {
        var quantityName = (quantity as MemberExpression)?.Member.Name;
        
        if (quantityName is null)
        {
            return;
        }

        var localQuantity = typeof(QuantityGroup).GetProperty(quantityName);

        if (localQuantity is null)
        {
            return;
        }

        foreach (var dbQuantity in dbQuantities)
        {
            var hasGroup = deckCards.TryGetValue(dbQuantity.CardId, out var localGroup);

            if (hasGroup && localQuantity.GetValue(localGroup) is not null)
            {
                continue;
            }

            if (hasGroup)
            {
                localQuantity.SetValue(localGroup, dbQuantity);
            }
            else
            {
                localGroup = new(dbQuantity);
                deckCards.Add(dbQuantity.CardId, localGroup);
            }

            dbContext.Attach(dbQuantity);
        }
    }


    private void CapDeletes(IEnumerable<QuantityGroup> deckCards)
    {
        foreach(var cardGroup in deckCards)
        {
            if (cardGroup.GiveBack is null)
            {
                continue;
            }

            var currentReturn = cardGroup.GiveBack.NumCopies;
            var capAmount = cardGroup.Amount?.NumCopies ?? currentReturn;

            cardGroup.GiveBack.NumCopies = Math.Min(currentReturn, capAmount);
        }
    }
}
