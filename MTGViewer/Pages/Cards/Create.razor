@page "/Cards/Create"
@attribute [Authorize]
@inherits OwningComponentBase

@using Microsoft.Extensions.DependencyInjection
@using MTGViewer.Data.Internal

@inject IDbContextFactory<CardDbContext> DbFactory

@inject SymbolFormatter MtgSymbols
@inject PageSizes PageSizes
@inject ILogger<Create> Logger


<PageTitle> Add Cards </PageTitle>

<h1>Add New Card(s)</h1>

<SavePrompt @bind-Result="_result">
    <SuccessMessage>
        New cards were successfully added.
    </SuccessMessage>
    <ErrorMessage>
        Ran into issues while try to add the new cards.
    </ErrorMessage>
</SavePrompt>

@if (!Matches.Any())
{
    <hr />
    <EditForm EditContext="@_searchEdit" OnValidSubmit="@SearchForCardAsync">
        <DataAnnotationsValidator />
        <div class="row">

            <div class="col-md order-md-last">
                <ValidationSummary role="alert"/>

                <section>
                    <h5> Or Operator </h5>
                    <p> 
                        All of the parameters (except Converted Mana Cost) can search with multiple values 
                        specified by adding the pipe character between each value. These multiple values act 
                        as a logical <strong>or</strong> for the search.
                    </p>

                    <p> Example or for Name: <code>jace|ajani|nissa, worldwaker</code> </p>
                </section>

                <section>
                    <h5> And Operator </h5>
                    <p>
                        Parameters that can have more than one value per card (Types, Supertypes, and Subtypes) 
                        can also have multiple values specified by adding a comma or space between each value. 
                        These multiple values act as a logical <strong>and</strong> for the search.
                    </p>

                    <p> Example and for Subtype(s): <code>bear,bird</code> or <code>bear bird</code> </p>
                    <p> 
                        Note that <strong>either</strong> the <i>and</i> or the <i>or</i> operator can be
                        applied on a given parameter value, not both.
                    </p>
                </section>

                <hr/>
                <section>
                    <h5> Type Parameters </h5>
                    <p>
                        All of the type parameters are specified on the type line of the card (the center description),
                        which is broken down into three different categories:
                    </p>

                    <dl class="row mb-0">
                        <dt class="col-12 col-lg-2"> Supertypes </dt>
                        <dd class="col-12 col-lg-10">
                            <p> Type information that is the most left of the type line </p>
                            <p> Examples: Basic, Legendary, Snow </p>
                        </dd>

                        <dt class="col-12 col-lg-2"> Types </dt>
                        <dd class="col-12 col-lg-10">
                            <p> Type information that follows immediately to the left of the dash. </p>
                            <p> Examples: Instant, Creature, Land, Planeswalker </p>
                        </dd>

                        <dt class="col-12 col-lg-2"> Subtypes </dt>
                        <dd class="col-12 col-lg-10">
                            <p> Type information that appears to the right of the dash. </p>
                            <p> Examples: Equipment, Aura, Human, Vampire </p>
                        </dd>
                    </dl>
                </section>
            </div>

            <hr class="d-md-none col-12"/>

            <div class="col-md col-lg-4">
                <p> Enter the card search parameters below </p>

                <div class="form-group">
                    <InputText @bind-Value="Query.Name" 
                        placeholder="@Query.DisplayName(c => c.Name)" 
                        class="form-control" />
                </div>

                <div class="form-group">
                    <InputNumber @bind-Value="Query.Cmc" min="0"
                        placeholder="@Query.DisplayName(c => c.Cmc)" 
                        class="form-control" />
                </div>

                <div class="form-group">
                    @foreach (var (symbol, color) in Color.Symbols)
                    {
                        <button title="toggle @color"
                            type="button"
                            class="btn btn-outline-secondary border-0 rounded @ActiveColor(color)"
                            @onclick="() => ColorToggle(color)">
                            <i class="ms ms-@symbol.ToLower() ms-cost"></i>
                        </button>
                    }

                    <div class="form-check mt-2 ml-2">
                        <InputCheckbox @bind-Value="_search.IsMultiColored"
                            class="form-check-input" id="@nameof(CardSearch.IsMultiColored)" />

                        <label class="form-check-label" for="@nameof(CardSearch.IsMultiColored)">
                            Multicolored Only
                        </label>
                    </div>
                </div>

                <div class="form-group">
                    <InputText @bind-Value="Query.Supertypes"
                        placeholder="@Query.DisplayName(c => c.Supertypes)"
                        class="form-control" />
                </div>

                <div class="form-group">
                    <InputText @bind-Value="Query.Types"
                        placeholder="@Query.DisplayName(c => c.Types)"
                        class="form-control" />
                </div>

                <div class="form-group">
                    <InputText @bind-Value="Query.Subtypes"
                        placeholder="@Query.DisplayName(c => c.Subtypes)"
                        class="form-control" />
                </div>

                <div class="form-group">
                    <InputText @bind-Value="Query.SetName" 
                        placeholder="@Query.DisplayName(c => c.SetName)" 
                        class="form-control" />
                </div>

                <div class="row form-group">
                    @for (int i = 0; i < Rarity.Values.Count; ++i)
                    {
                        var rarity = Rarity.Values[i];
                        var toggleId = $"{rarity}-toggle";

                        <div class="col-6">
                            <div class="form-check form-check-inline ml-2">

                                <input class="form-check-input" id="@toggleId"
                                    type="checkbox" value="@rarity"
                                    checked="@IsRaritySelected(rarity)" 
                                    @onchange="() => RarityToggle(rarity)" />

                                <label class="form-check-label" for="@toggleId"> @rarity </label>
                            </div>
                        </div>
                    }
                </div>

                <div class="form-group">
                    <InputText @bind-Value="Query.Artist" 
                        placeholder="@Query.DisplayName(c => c.Artist)" 
                        class="form-control" />
                </div>

                <div class="form-group">
                    <InputText @bind-Value="Query.Power" 
                        placeholder="@Query.DisplayName(c => c.Power)" 
                        class="form-control" />
                </div>

                <div class="form-group">
                    <InputText @bind-Value="Query.Toughness" 
                        placeholder="@Query.DisplayName(c => c.Toughness)" 
                        class="form-control" />
                </div>

                <div class="form-group">
                    <InputText @bind-Value="Query.Loyalty" 
                        placeholder="@Query.DisplayName(c => c.Loyalty)" 
                        class="form-control" />
                </div>

                <div class="btn-group" role="group">

                    <button type="button" class="btn btn-danger" 
                        @onclick="Reset" title="Reset All Fields"
                        disabled="@IsBusy">
                        Reset </button>

                    <button type="submit" class="btn btn-secondary" 
                        title="Search For Card" disabled="@IsBusy">
                        @if (IsBusy)
                        {
                            <text>
                                <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"> </span>
                                Loading...
                            </text>
                        }
                        else
                        {
                            <text> Search </text>
                        }
                    </button>
                </div>
            </div>
        </div>
    </EditForm>
}
else
{
    <div class="btn-group" role="group">
        <button title="Reset Button" type="button"
            @onclick="Reset" 
            disabled="@IsBusy"
            class="btn btn-danger">
            Reset </button>

        <button title="Add Button" type="button"
            class="btn btn-secondary"
            @onclick="AddNewCardsAsync" 
            disabled="@(CannotAdd() || IsBusy)">
            Add Cards/Amounts </button>
    </div>

    <div class="row align-items-center my-3">

        <div class="col-12 col-md-4">
            <input class="form-control" placeholder="Name" @bind="_search.MatchName" />
        </div>

        <div class="col-auto btn-group pt-2 pt-md-0" role="group" aria-label="Color Buttons">
            @foreach (var (symbol, color) in Color.Symbols)
            {
                <button title="@color filter"
                    type="button"
                    class="btn btn-outline-secondary border-0 rounded @ActiveColor(color)"
                    @onclick="() => ColorToggle(color)">

                    <i class="ms ms-@symbol.ToLower() ms-cost"></i>
                </button>
            }
        </div>
    </div>

    <div class="table-responsive-md">
        <table class="table">
            <thead>
                <tr>
                    <th scope="col"> @DisplayName(c => c.Name) </th>
                    <th scope="col"> @DisplayName(c => c.ManaCost) </th>
                    <th scope="col"> @DisplayName(c => c.SetName) </th>
                    <th scope="col"> @DisplayName(c => c.Rarity) </th>
                    <th scope="col"> Amount </th>
                </tr>
            </thead>
            <tbody>
                @foreach (var match in Matches)
                {
                    @if (MatchPassesFilters(match))
                    {
                        var card = match.Card;
                        <tr>
                            <td> 
                                <HoverCard Target="card">
                                    <span class="btn-link">@card.Name</span> 
                                </HoverCard> 
                            </td>
                            <td> @MtgSymbols.Format(card.ManaCost).ToMarkupString() </td>
                            <td> @card.SetName </td>
                            <td> @card.Rarity </td>
                            <td>
                                <input @bind="match.NumCopies"
                                    title="@card.Name Amount" 
                                    type="number" min="0" max="@PageSizes.Limit"
                                    class="form-control w-50" />
                            </td>
                        </tr>
                    }
                }
            </tbody>
        </table>
    </div>

    <button title="More Results" type="button"
        class="btn btn-secondary"
        @onclick="SearchForCardAsync" 
        disabled="@(HasNoNext || IsBusy)" >
        @if (IsBusy)
        {
            <text>
                <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"> </span>
                Loading...
            </text>
        }
        else
        {
            <text> Load More </text>
        }
    </button>
}


@code
{
    public CardQuery Query => _search.Query;

    public bool IsBusy => _isBusy;
    public bool HasNoNext => !_matchPage.HasNext;

    public IReadOnlyList<MatchInput> Matches => _matches;

    public bool CannotAdd() =>
        !_matches.Any() || _matches.All(m => m.NumCopies == 0);


    private readonly CancellationTokenSource _cancel = new();
    private bool _isBusy;
    private SaveResult _result;

    private readonly CardSearch _search = new();
    private EditContext? _searchEdit;
    private ValidationMessageStore? _resultErrors;

    private readonly List<MatchInput> _matches = new();
    private Pages _matchPage;


    private sealed class CardSearch
    {
        public CardQuery Query { get; } = new();

        public HashSet<string> PickedRarities { get; } = new(StringComparer.OrdinalIgnoreCase);

        public HashSet<string> PickedColors { get; } = new(StringComparer.OrdinalIgnoreCase);

        public bool IsMultiColored { get; set; }

        public string? MatchName { get; set; }
    }


    public sealed class MatchInput
    {
        private readonly int _limit;
        private int _numCopies;

        public MatchInput(Card card, int limit)
        {
            Card = card;
            _limit = limit;
        }

        public Card Card { get; }

        public int NumCopies
        {
            get => _numCopies;
            set
            {
                if (value >= 0 && value <= _limit)
                {
                    _numCopies = value;
                }
            }
        }
    }


    protected override void OnInitialized()
    {
        _searchEdit = new(_search.Query);
        _resultErrors = new(_searchEdit);

        Reset();

        _searchEdit.OnValidationRequested += ClearErrors;
        _searchEdit.OnFieldChanged += ClearErrors;
    }


    protected override void Dispose(bool disposing)
    {
        if (disposing)
        {
            if (_searchEdit is not null)
            {
                _searchEdit.OnValidationRequested -= ClearErrors;
                _searchEdit.OnFieldChanged -= ClearErrors;
            }

            _cancel.Cancel();
            _cancel.Dispose();
        }

        base.Dispose(disposing);
    }
    


    public string DisplayName<T>(Expression<Func<Card, T>> property) =>
        EntityExtensions.DisplayName(property);

    public string ActiveColor(string color) =>
        _search.PickedColors.Contains(color) ? "active" : string.Empty;

    public bool IsRaritySelected(string rarity) =>
        _search.PickedRarities.Contains(rarity);



    private void ClearErrors(object? sender, ValidationRequestedEventArgs args)
    {
        if (_searchEdit is null || _resultErrors is null)
        {
            return;
        }

        _resultErrors.Clear();
        _searchEdit.NotifyValidationStateChanged();
    }


    private void ClearErrors(object? sender, FieldChangedEventArgs args)
    {
        if (_searchEdit is null || _resultErrors is null)
        {
            return;
        }

        var idField = _searchEdit.Field(nameof(CardQuery.Id));

        _resultErrors.Clear(idField);
        _resultErrors.Clear(args.FieldIdentifier);

        _searchEdit.NotifyValidationStateChanged();
    }


    private void NoMatchError()
    {
        if (_searchEdit is null || _resultErrors is null)
        {
            return;
        }

        var idField = _searchEdit.Field(nameof(CardQuery.Id));
        var noMatch = new []{ "No matches were found" };

        _resultErrors.Add(idField, noMatch);
        _searchEdit.NotifyValidationStateChanged();
    }


    public void ColorToggle(string color)
    {
        if (_searchEdit is null)
        {
            return;
        }

        var pickedColors = _search.PickedColors;
        var colorField = _searchEdit.Field(nameof(CardQuery.Colors));

        if (pickedColors.Contains(color))
        {
            pickedColors.Remove(color);
        }
        else
        {
            pickedColors.Add(color);
        }

        _searchEdit.NotifyFieldChanged(colorField);
    }


    public void RarityToggle(string rarity)
    {
        var pickedRarities = _search.PickedRarities;

        if (pickedRarities.Contains(rarity))
        {
            pickedRarities.Remove(rarity);
        }
        else
        {
            pickedRarities.Add(rarity);
        }
    }


    public async Task SearchForCardAsync()
    {
        if (_isBusy || (_matchPage != default && !_matchPage.HasNext))
        {
            return;
        }

        _result = SaveResult.None;
        _isBusy = true;

        try
        {
            PrepareSearch(_search, _matchPage);

            var cancelToken = _cancel.Token;
            var limit = PageSizes.Limit;

            var fetch = ScopedServices.GetRequiredService<MTGFetchService>();

            var result = await fetch
                .Where(_search.Query)
                .SearchAsync();

            cancelToken.ThrowIfCancellationRequested();

            _matches.AddRange(
                result.Select(c => new MatchInput(c, limit)));

            _matchPage = result.Pages;

            if (!_matches.Any())
            {
                NoMatchError();
            }
        }
        catch (OperationCanceledException ex)
        {
            Logger.LogError(ex.ToString());
        }
        finally
        {
            _isBusy = false;
        }
    }


    private static void PrepareSearch(CardSearch search, Data.Pages matchPage)
    {
        var query = search.Query;
        var colorJoin = search.IsMultiColored ? MTGFetchService.And : MTGFetchService.Or;

        query.Colors = string.Join(colorJoin, search.PickedColors);
        query.Rarity = string.Join(MTGFetchService.Or, search.PickedRarities);

        query.Page = matchPage == default ? 0 : matchPage.Current + 1;
    }


    private bool MatchPassesFilters(MatchInput match)
    {
        const StringComparison ignoreCase = StringComparison.CurrentCultureIgnoreCase;

        string? matchName = _search.MatchName;
        var pickedColors = _search.PickedColors;

        var card = match.Card;
        var cardColors = card.Colors.Select(c => c.Name);

        bool nameMatches = string.IsNullOrWhiteSpace(matchName) 
            || card.Name.Contains(matchName, ignoreCase);

        bool colorMatches = !pickedColors.Any() 
            || pickedColors.Overlaps(cardColors);

        return nameMatches && colorMatches;
    }


    public void Reset()
    {
        if (_isBusy || _searchEdit is null)
        {
            return;
        }

        _matches.Clear();
        _matchPage = default;

        var query = _search.Query;

        _search.PickedColors.Clear();
        _search.PickedRarities.Clear();

        // TODO: use reflection to reset

        query.Name = default;
        query.Cmc = default;
        query.Colors = default;
        query.Rarity = default;
        query.SetName = default;

        query.Supertypes = default;
        query.Types = default;
        query.Subtypes = default;

        query.Artist = default;
        query.Power = default;
        query.Toughness = default;
        query.Loyalty = default;

        query.PageSize = PageSizes.GetComponentSize<Create>();

        // force data validation, might be inefficient
        _searchEdit.Validate();
    }


    public async Task AddNewCardsAsync()
    {
        if (_isBusy)
        {
            return;
        }

        var addedAmounts = _matches
            .Where(m => m.NumCopies > 0 && m.NumCopies <= PageSizes.Limit)
            .Select(m => new CardRequest(m.Card, m.NumCopies))
            .ToList();

        if (!addedAmounts.Any())
        {
            return;
        }

        _result = SaveResult.None;
        _isBusy = true;

        try
        {
            var cancelToken = _cancel.Token;

            await using var dbContext = await DbFactory.CreateDbContextAsync(cancelToken);

            await AddNewCardsAsync(dbContext, addedAmounts, PageSizes.Limit, cancelToken);

            await dbContext.AddCardsAsync(addedAmounts, cancelToken);

            await dbContext.SaveChangesAsync(cancelToken);

            _result = SaveResult.Success;
        }
        catch (DbUpdateException e)
        {
            Logger.LogError($"failed to add new cards {e}");

            _result = SaveResult.Error;
        }
        catch (InvalidOperationException e)
        {
            Logger.LogError($"failed to add new cards {e}");

            _result = SaveResult.Error;
        }
        catch (OperationCanceledException e)
        {
            Logger.LogError($"cancel error: {e}");

            _result = SaveResult.Error;
        }
        finally
        {
            _isBusy = false;

            Reset();
        }
    }


    private static async Task AddNewCardsAsync(
        CardDbContext dbContext,
        IReadOnlyList<CardRequest> requests,
        int limit,
        CancellationToken cancel)
    {
        var requestCards = requests
            .Select(cr => cr.Card)
            .ToList();

        var existingIds = await ExistingCardIdsAsync(dbContext, requestCards, limit, cancel);

        var existingCards = requestCards
            .IntersectBy(existingIds, c => c.Id);

        var newCards = requestCards
            .ExceptBy(existingIds, c => c.Id);

        dbContext.Cards.AttachRange(existingCards);
        dbContext.Cards.AddRange(newCards);
    }


    private static Task<List<string>> ExistingCardIdsAsync(
        CardDbContext dbContext,
        IReadOnlyList<Card> cards,
        int limit,
        CancellationToken cancel)
    {
        if (cards.Count > limit)
        {
            var cardIds = cards
                .Select(c => c.Id)
                .ToAsyncEnumerable();

            return dbContext.Cards
                .Select(c => c.Id)
                .AsAsyncEnumerable()
                .Intersect(cardIds)
                .ToListAsync(cancel)
                .AsTask();
        }
        else
        {
            var cardIds = cards
                .Select(c => c.Id)
                .ToArray();

            return dbContext.Cards
                .Select(c => c.Id)
                .Where(cid => cardIds.Contains(cid))
                .ToListAsync(cancel);
        }
    }
}
