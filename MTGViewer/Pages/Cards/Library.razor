@page "/Cards"
@implements IDisposable

@using System.Collections.Immutable
@using MTGViewer.Data.Internal

@inject FixedCache Cache
@inject IDbContextFactory<CardDbContext> DbFactory
@inject SymbolFormatter MtgSymbols
@inject PageSizes PageSizes

@inject ILogger<Library> Logger


<PageTitle> Card Collection </PageTitle>

<h1>Card Collection</h1>

<AuthorizeView>
    <div class="btn-group" role="group">
        <a class="btn btn-secondary" href="/Cards/Create" role="button">Add Card</a>
    </div>
</AuthorizeView>

<div class="form-row align-items-center my-3">
    <div class="col-12 col-md-4">
        <input class="form-control" 
            placeholder="Card Name" 
            disabled="@IsBusy"
            @onchange="SearchNameAsync" />
    </div>

    <div class="col-auto btn-group pt-2 pt-md-0" role="group" aria-label="Color Buttons">
        @foreach (var (symbol, color) in Color.Symbols)
        {
            <button title="@color filter"
                type="button"
                class="btn btn-outline-secondary border-0 rounded @ColorActive(color)"
                disabled="@IsBusy"
                @onclick="() => FilterColorAsync(color)">

                <i class="ms ms-@symbol.ToLower() ms-cost"></i>
            </button>
        }
    </div>
</div>

<div class="table-responsive-md">
    <table class="table">
        <thead>
            <tr>
                <th scope="col"
                    title="Order By Name"
                    @onclick="() => ReorderCardsAsync(c => c.Name)" 
                    class="@HeaderClass(c => c.Name)">
                    @DisplayName(c => c.Name)
                    @Direction(c => c.Name)
                </th>

                <th scope="col" 
                    title="Order By Cmc"
                    @onclick="() => ReorderCardsAsync(c => c.ManaCost)" 
                    class="@HeaderClass(c => c.ManaCost)">
                    @DisplayName(c => c.ManaCost)
                    @Direction(c => c.ManaCost)
                </th>

                <th scope="col"
                    title="Order By Set Name"
                    @onclick="() => ReorderCardsAsync(c => c.SetName)" 
                    class="@HeaderClass(c => c.SetName)">
                    @DisplayName(c => c.SetName)
                    @Direction(c => c.SetName)
                </th>

                <th scope="col"
                    title="Order By Rarity"
                    @onclick="() => ReorderCardsAsync(c => c.Rarity)" 
                    class="@HeaderClass(c => c.Rarity)">
                    @DisplayName(c => c.Rarity)
                    @Direction(c => c.Rarity)
                </th>

                <th scope="col" 
                    title="Order By Number of Copies"
                    @onclick="() => ReorderCardsAsync(c => c.Amounts)" 
                    class="@HeaderClass(c => c.Amounts)">
                    Total Copies
                    @Direction(c => c.Amounts)
                </th>

                <AuthorizeView>
                    <th scope="col"></th>
                </AuthorizeView>
            </tr>
        </thead>

        <tbody>
            @foreach (var card in Cards)
            {
                <tr>
                    <td> <HoverCard Target="card"/> </td>

                    <td> @(MtgSymbols.Format(card.ManaCost).ToMarkupString()) </td>
                    <td> @card.SetName </td>
                    <td> @card.Rarity </td>
                    <td> @CardTotal(card) </td>

                    <AuthorizeView>
                        <td>
                            <a title="Suggest @card.Name"
                                href="/Transfers/Suggest/@card.Id"
                                class="btn btn-secondary"
                                role="button">
                                Suggest </a>
                        </td>
                    </AuthorizeView>
                </tr>
            }
        </tbody>
    </table>
</div>

<Pagination Pages="Cards.Pages" PageSelected="(index) => FetchCardsAsync(index)"></Pagination>


@code {

    private bool _isBusy;
    private readonly CancellationTokenSource _cancel = new();

    private readonly HashSet<Card> _loadedCards = new();
    private readonly Dictionary<string, int> _cardAmounts = new();

    private readonly FilterContext _filters = new();
    private PagedList<Card> _pagedCards = PagedList<Card>.Empty;


    private PagedList<Card> Cards => _pagedCards;

    private bool IsBusy => _isBusy;


    private int CardTotal(Card card) =>
        _cardAmounts.GetValueOrDefault(card.Id);


    private string ColorActive(string color) =>
        _filters.PickedColors.Contains(color) ? "active" : string.Empty;


    private string HeaderClass<T>(Expression<Func<Card, T>> property)
    {
        if (_isBusy)
        {
            return string.Empty;
        }
        else if (_filters.OrderBy == null || MemberName(property) != _filters.OrderBy)
        {
            return "clickable btn-link";
        }
        else
        {
            return "clickable btn-link font-weight-bold";
        }
    }


    private static string DisplayName<T>(Expression<Func<Card, T>> property) =>
        EntityExtensions.DisplayName(property);


    private RenderFragment Direction<T>(Expression<Func<Card, T>> property)
    {
        bool invalid = _isBusy
            || _filters.OrderBy == null
            || MemberName(property) != _filters.OrderBy;

        return _filters.IsReversed switch
        {
            _ when invalid => @<text></text>,
            true => @<text>&#9650;</text>,
            false => @<text>&#9660;</text>
        };
    }

    private static string? MemberName<T>(Expression<Func<Card, T>> property) =>
        (property.Body as MemberExpression)?.Member.Name;



    protected override Task OnInitializedAsync()
    {
        _filters.PageSize = PageSizes.GetComponentSize<Library>();

        return FetchCardsAsync(shouldCache: false);
    }


    public void Dispose()
    {
        _cancel.Cancel();
        _cancel.Dispose();
    }



    #region Fetch

    private class FilterContext
    {
        public HashSet<string> PickedColors { get; } = new(StringComparer.CurrentCultureIgnoreCase);

        public string? SearchName { get; set; }

        public string? OrderBy { get; set; }

        public bool IsReversed { get; set; }

        public int PageSize { get; set; }

        public int PageIndex { get; set; }
    }


    private async Task FetchCardsAsync(int pageIndex = 0, bool shouldCache = false)
    {
        if (_isBusy
            || _filters.PageSize <= 0
            || pageIndex < 0 
            || _pagedCards.Pages.Total is int totalPages
                && totalPages > 0
                && pageIndex >= totalPages)
        {
            return;
        }

        _isBusy = true;

        try
        {
            _filters.OrderBy ??= nameof(Card.Name);
            _filters.PageIndex = pageIndex;

            await using var dbContext = await DbFactory.CreateDbContextAsync(_cancel.Token);

            dbContext.AttachRange(_loadedCards); // reuse prior card objs

            _pagedCards = !shouldCache
                ? await GetFilteredCardsAsync(dbContext, _filters, _cancel.Token)
                : await Cache
                    .GetOrCreateAsync(nameof(_pagedCards), () =>
                        GetFilteredCardsAsync(dbContext, _filters, _cancel.Token));

            var cardAmounts = !shouldCache
                ? await GetCardAmountsAsync(dbContext, _pagedCards, _cancel.Token)
                : await Cache
                    .GetOrCreateAsync("cardAmounts", () => 
                        GetCardAmountsAsync(dbContext, _pagedCards, _cancel.Token));

            _loadedCards.UnionWith(_pagedCards);

            foreach ((string cardId, int total) in cardAmounts)
            {
                _cardAmounts[cardId] = total;
            }
        }
        catch (OperationCanceledException ex)
        {
            Logger.LogError(ex.ToString());
        }
        finally
        {
            _isBusy = false;
        }
    }


    private static Task<PagedList<Card>> GetFilteredCardsAsync(
        CardDbContext dbContext,
        FilterContext filters,
        CancellationToken cancel)
    {
        var cards = dbContext.Cards.AsQueryable();

        var searchName = filters.SearchName;
        var pickedColors = filters.PickedColors;

        if (!string.IsNullOrWhiteSpace(searchName))
        {
            string name = searchName.ToLower();

            // keep eye on perf, postgres is slow here
            cards = cards.Where(c => 
                c.Name.ToLower().Contains(name));
        }

        if (pickedColors.Any())
        {
            cards = cards.Where(c =>
                c.Colors.Any(cl => pickedColors.Contains(cl.Name)));
        }

        bool dbEval = filters.OrderBy switch
        {
            nameof(Card.Rarity) => false,
            _ => true
        };

        int pageSize = filters.PageSize;
        int pageIndex = filters.PageIndex;

        return dbEval
            ? CardsOrdered(cards, filters)
                .ToPagedListAsync(pageSize, pageIndex, cancel)

            : CardsOrdered(cards.AsAsyncEnumerable(), filters)
                // paging is kind of pointless since server eval is unbounded
                .ToPagedListAsync(pageSize, pageIndex, cancel);
    }


    private static IQueryable<Card> CardsOrdered(
        IQueryable<Card> cards, FilterContext filters)
    {
        IOrderedQueryable<Card> PrimaryOrder<T>(
            Expression<Func<Card, T>> property)
        {
            return IsAscending(filters.OrderBy) ^ filters.IsReversed
                ? cards.OrderBy(property)
                : cards.OrderByDescending(property);
        }

        return filters.OrderBy switch
        {
            nameof(Card.ManaCost) => 
                PrimaryOrder(c => c.Cmc)
                    .ThenBy(c => c.Name)
                    .ThenBy(c => c.SetName),

            nameof(Card.SetName) =>
                PrimaryOrder(c => c.SetName)
                    .ThenBy(c => c.Name),

            nameof(Card.Amounts) => 
                PrimaryOrder(c => c.Amounts.Sum(a => a.NumCopies))
                    .ThenBy(c => c.Name)
                    .ThenBy(c => c.SetName),

            _ => PrimaryOrder(c => c.Name)
                    .ThenBy(c => c.SetName)
        };
    }


    private static IAsyncEnumerable<Card> CardsOrdered(
        IAsyncEnumerable<Card> cards, FilterContext filters)
    {
        IOrderedAsyncEnumerable<Card> PrimaryOrder<T>(
            Func<Card, T> property, IComparer<T> comparer)
        {
            return IsAscending(filters.OrderBy) ^ filters.IsReversed
                ? cards.OrderBy(property, comparer)
                : cards.OrderByDescending(property, comparer);
        }

        // custom order comparers are not supported in ef core
        return filters.OrderBy switch
        {
            nameof(Card.Rarity) or _ => 
                PrimaryOrder(c => c.Rarity, new RarityComparer())
                    .ThenBy(c => c.Name)
                    .ThenBy(c => c.SetName),
        };
    }


    private static bool IsAscending(string? property) => property switch
    {
        nameof(Card.ManaCost) => true,
        nameof(Card.SetName) => true,
        nameof(Card.Rarity) => false,
        nameof(Card.Amounts) => false,
        _ => true
    };


    private static Task<Dictionary<string, int>> GetCardAmountsAsync(
        CardDbContext dbContext, 
        IEnumerable<Card> cards,
        CancellationToken cancel)
    {
        var cardIds = cards
            .Select(c => c.Id)
            .ToArray();

        return dbContext.Amounts
            .Where(a => cardIds.Contains(a.CardId))
            .GroupBy(a => a.CardId,
                (CardId, cas) =>
                    new { CardId, Total = cas.Sum(ca => ca.NumCopies) })

            .ToDictionaryAsync(
                ct => ct.CardId, ct => ct.Total, cancel);
    }

    #endregion



    private Task FilterColorAsync(string color)
    {
        if (_isBusy)
        {
            return Task.CompletedTask;
        }

        var pickedColors = _filters.PickedColors;

        if (pickedColors.Contains(color))
        {
            pickedColors.Remove(color);
        }
        else
        {
            pickedColors.Add(color);
        }

        return FetchCardsAsync();
    }


    private Task SearchNameAsync(ChangeEventArgs eventArgs)
    {
        if (_isBusy)
        {
            return Task.CompletedTask;
        }

        _filters.SearchName = eventArgs.Value?.ToString();
        
        return FetchCardsAsync();
    }


    private Task ReorderCardsAsync<T>(Expression<Func<Card, T>> property)
    {
        if (_isBusy || MemberName(property) is not string newOrder)
        {
            return Task.CompletedTask;
        }

        string? oldOrder = _filters.OrderBy;

        _filters.IsReversed = newOrder == oldOrder && !_filters.IsReversed;
        _filters.OrderBy = newOrder;

        return FetchCardsAsync();
    }
}
