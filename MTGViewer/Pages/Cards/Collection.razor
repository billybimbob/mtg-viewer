@page "/Cards"
@implements IDisposable

@using System.Collections.Immutable
@using MTGViewer.Data.Internal

@inject IDbContextFactory<CardDbContext> DbFactory
@inject SymbolFormatter MtgSymbols
@inject PageSizes PageSizes
@inject ILogger<Collection> Logger

@using MTGViewer.Areas.Identity.Data

<PageTitle> Card Collection </PageTitle>

<h1>Card Collection</h1>

<div class="btn-group" role="group">
    <AuthorizeView Policy="@CardPolicies.ChangeTreasury">
        <Authorized>
            <a class="btn btn-secondary" href="/Cards/Create" role="button">Add Card</a>
        </Authorized>
        <NotAuthorized>
            <button class="btn btn-secondary" role="button" disabled>Add Card</button>
        </NotAuthorized>
    </AuthorizeView>
</div>

<div class="form-row align-items-center my-3">
    <div class="col-12 col-md-4">
        <input class="form-control" 
            placeholder="Card Name" 
            disabled="@IsBusy"
            @bind="Filters.SearchName" />
    </div>

    <div class="col-auto btn-group pt-2 pt-md-0" role="group" aria-label="Color Buttons">
        @foreach (var (symbol, color) in Color.Symbols)
        {
            <button title="@color filter"
                type="button"
                class="btn btn-outline-secondary border-0 rounded @ColorActive(color)"
                disabled="@IsBusy"
                @onclick="() => Filters.ToggleColor(color)">

                <i class="ms ms-@symbol.ToLower() ms-cost"></i>
            </button>
        }
    </div>

    @if (IsBusy)
    {
        <div class="spinner-grow text-secondary p-2" role="status">
            <span class="sr-only">Loading...</span>
        </div>
    }
</div>

<div class="table-responsive-md">
    <table class="table">
        <thead>
            <tr>
                <th scope="col"
                    title="Order By Name"
                    @onclick="() => Filters.Reorder(c => c.Name)" 
                    class="@HeaderClass(c => c.Name)">
                    @DisplayName(c => c.Name)
                    @Direction(c => c.Name)
                </th>

                <th scope="col" 
                    title="Order By Cmc"
                    @onclick="() => Filters.Reorder(c => c.ManaCost)" 
                    class="@HeaderClass(c => c.ManaCost)">
                    @DisplayName(c => c.ManaCost)
                    @Direction(c => c.ManaCost)
                </th>

                <th scope="col"
                    title="Order By Set Name"
                    @onclick="() => Filters.Reorder(c => c.SetName)" 
                    class="@HeaderClass(c => c.SetName)">
                    @DisplayName(c => c.SetName)
                    @Direction(c => c.SetName)
                </th>

                <th scope="col"
                    title="Order By Rarity"
                    @onclick="() => Filters.Reorder(c => c.Rarity)" 
                    class="@HeaderClass(c => c.Rarity)">
                    @DisplayName(c => c.Rarity)
                    @Direction(c => c.Rarity)
                </th>

                <th scope="col" 
                    title="Order By Number of Copies"
                    @onclick="() => Filters.Reorder(c => c.Amounts)" 
                    class="@HeaderClass(c => c.Amounts)">
                    Total Copies
                    @Direction(c => c.Amounts)
                </th>

                <AuthorizeView Policy="@CardPolicies.ChangeTreasury">
                    <th scope="col"></th>
                </AuthorizeView>
            </tr>
        </thead>

        <tbody>
            @foreach (var card in Cards)
            {
                <tr>
                    <td> <HoverCard Target="card"/> </td>

                    <td>
                        <div class="ms-group">
                            @MtgSymbols.Format(card.ManaCost).ToMarkupString()
                        </div>
                    </td>
                    <td> @card.SetName </td>
                    <td> @card.Rarity </td>
                    <td> @CardTotal(card) </td>

                    <AuthorizeView Policy="@CardPolicies.ChangeTreasury">
                        <td>
                            <a title="Suggest @card.Name"
                                href="/Transfers/Suggest/@card.Id"
                                class="btn btn-secondary"
                                role="button">
                                Suggest </a>
                        </td>
                    </AuthorizeView>
                </tr>
            }
        </tbody>
    </table>
</div>

<OffsetPaging Offset="Cards.Offset" PageSelected="p => Filters.PageIndex = p"></OffsetPaging>


@code
{
    private const int SearchNameLimit = 40;

    private bool _isBusy;
    private readonly CancellationTokenSource _cancel = new();
    private readonly Loader _loader = new();
    private readonly FilterContext _filters = new();


    public bool IsBusy => _isBusy;

    public FilterContext Filters => _filters;

    public OffsetList<Card> Cards => _loader.Cards ?? OffsetList<Card>.Empty();


    public int CardTotal(Card card) => _loader.CardTotal(card);


    public string ColorActive(string color) =>
        _filters.PickedColors.Contains(color) ? "active" : string.Empty;


    public string HeaderClass<T>(Expression<Func<Card, T>> property)
    {
        if (IsBusy)
        {
            return string.Empty;
        }
        else if (_filters.OrderBy == null || MemberName(property) != _filters.OrderBy)
        {
            return "clickable btn-link";
        }
        else
        {
            return "clickable btn-link font-weight-bold";
        }
    }


    public static string DisplayName<T>(Expression<Func<Card, T>> property) =>
        EntityExtensions.DisplayName(property);


    public RenderFragment Direction<T>(Expression<Func<Card, T>> property)
    {
        bool invalid = IsBusy
            || _filters.OrderBy == null
            || MemberName(property) != _filters.OrderBy;

        return _filters.IsReversed switch
        {
            _ when invalid => @<text></text>,
            true => @<text>&#9650;</text>,
            false => @<text>&#9660;</text>
        };
    }

    private static string? MemberName<T>(Expression<Func<Card, T>> property) =>
        (property.Body as MemberExpression)?.Member.Name;



    protected override async Task OnInitializedAsync()
    {
        if (_isBusy)
        {
            return;
        }

        _isBusy = true;

        _filters.LoadContext = new LoadContext(this);
        _filters.PageSize = PageSizes.GetComponentSize<Collection>();

        try
        {
            await _loader.LoadCardsAsync(DbFactory, _filters, _cancel.Token);
        }
        catch (OperationCanceledException ex)
        {
            Logger.LogError(ex.ToString());
        }
        catch (Exception ex)
        {
            Logger.LogError(ex.ToString());
        }
        finally
        {
            _isBusy = false;
        }
    }


    public void Dispose()
    {
        _cancel.Cancel();
        _cancel.Dispose();
    }



    public sealed class FilterContext
    {
        private LoadContext _loadContext;
        internal LoadContext LoadContext
        {
            set => _loadContext = value;
        }

        private string? _searchName;
        public string? SearchName
        {
            get => _searchName;
            set
            {
                if (_loadContext.IsBusy
                    || value?.Length > SearchNameLimit
                    || value == _searchName
                    || string.IsNullOrWhiteSpace(value)
                        && string.IsNullOrWhiteSpace(_searchName))
                {
                    return;
                }

                if (_pageIndex > 0)
                {
                    _pageIndex = 0;
                }

                _searchName = value;
                
                _loadContext.LoadCardsAsync();
            }
        }

        private string _orderBy = nameof(Card.Name);
        public string OrderBy
        {
            get => _orderBy;
            private set
            {
                if (_loadContext.IsBusy)
                {
                    return;
                }

                if (value != _orderBy && _pageIndex > 0)
                {
                    _pageIndex = 0;
                }

                IsReversed = value == _orderBy && !IsReversed;
                _orderBy = value;

                _loadContext.LoadCardsAsync();
            }
        }

        public void Reorder<T>(Expression<Func<Card, T>> property)
        {
            if (MemberName(property) is not string newOrder)
            {
                return;
            }

            OrderBy = newOrder;
        }

        public bool IsReversed { get; private set; }

        private int _pageSize = 1;
        public int PageSize
        {
            get => _pageSize;
            set
            {
                if (value <= 0 || value == _pageSize)
                {
                    return;
                }

                if (_pageIndex > 0)
                {
                    _pageIndex = 0;
                }

                _pageSize = value;

                _loadContext.LoadCardsAsync();
            }
        }

        private int _pageIndex;
        public int PageIndex
        {
            get => _pageIndex;
            set
            {
                if (_loadContext.IsBusy
                    || value < 0
                    || value == _pageIndex
                    || value >= _loadContext.MaxPage)
                {
                    return;
                }

                _pageIndex = value;

                _loadContext.LoadCardsAsync();
            }
        }

        private readonly HashSet<string> _pickedColors = new(StringComparer.CurrentCultureIgnoreCase);
        public IReadOnlyCollection<string> PickedColors => _pickedColors;

        public void ToggleColor(string color)
        {
            if (_loadContext.IsBusy)
            {
                return;
            }

            if (_pickedColors.Contains(color))
            {
                _pickedColors.Remove(color);
            }
            else
            {
                _pickedColors.Add(color);
            }

            if (_pageIndex > 0)
            {
                _pageIndex = 0;
            }

            _loadContext.LoadCardsAsync();
        }
    }


    internal readonly struct LoadContext
    {
        private readonly Collection? _parent;

        public LoadContext(Collection parent)
        {
            _parent = parent;
        }

        public int MaxPage =>
            _parent?.Cards.Offset.Total ?? 0;

        public bool IsBusy => _parent?.IsBusy ?? true;

        public Task LoadCardsAsync()
        {
            return _parent is null || _parent.IsBusy
                ? Task.CompletedTask
                : _parent.LoadCardsAsync();
        }
    }


    private async Task LoadCardsAsync()
    {
        if (_isBusy)
        {
            return;
        }

        _isBusy = true;

        try
        {
            await _loader.LoadCardsAsync(DbFactory, _filters, _cancel.Token);
        }
        catch (OperationCanceledException ex)
        {
            Logger.LogError(ex.ToString());
        }
        catch (Exception ex)
        {
            Logger.LogError(ex.ToString());
        }
        finally
        {
            _isBusy = false;

            StateHasChanged();
        }
    }


    private sealed class Loader
    {
        private readonly HashSet<Card> _loadedCards = new();
        private readonly Dictionary<string, int> _cardAmounts = new();
        private OffsetList<Card>? _pagedCards;

        public OffsetList<Card>? Cards => _pagedCards;

        public int CardTotal(Card card)
        {
            if (card is null)
            {
                throw new ArgumentNullException(nameof(card));
            }

            return _cardAmounts.GetValueOrDefault(card.Id);
        }


        public async Task LoadCardsAsync(
            IDbContextFactory<CardDbContext> dbFactory, 
            FilterContext filters,
            CancellationToken cancel)
        {
            await using var dbContext = await dbFactory.CreateDbContextAsync(cancel);

            dbContext.AttachRange(_loadedCards); // reuse prior card objs

            var newCards = await FilteredCardsAsync(dbContext, filters, cancel);
            var cardAmounts = await CardAmountsAsync(dbContext, newCards, cancel);

            _loadedCards.UnionWith(newCards);

            foreach ((string cardId, int total) in cardAmounts)
            {
                _cardAmounts[cardId] = total;
            }

            _pagedCards = newCards;
        }
    }



    #region Fetch Queries

    private static Task<OffsetList<Card>> FilteredCardsAsync(
        CardDbContext dbContext,
        FilterContext filters,
        CancellationToken cancel)
    {
        var cards = dbContext.Cards.AsQueryable();

        var searchName = filters.SearchName;
        var pickedColors = filters.PickedColors;

        if (!string.IsNullOrWhiteSpace(searchName))
        {
            // keep eye on perf, postgres is slow here
            cards = cards
                .Where(c => c.Name.ToLower()
                    .Contains(searchName.ToLower()));
        }

        if (pickedColors.Any())
        {
            cards = cards
                .Where(c => c.Colors
                    .Any(cl => pickedColors.Contains(cl.Name)));
        }

        int pageSize = filters.PageSize;
        int pageIndex = filters.PageIndex;

        return CardsOrdered(cards, filters)
            .ToOffsetListAsync(pageSize, pageIndex, cancel);
    }


    private static IQueryable<Card> CardsOrdered(IQueryable<Card> cards, FilterContext filters)
    {
        bool isAscending = filters.OrderBy switch
        {
            nameof(Card.ManaCost) => true,
            nameof(Card.SetName) => true,
            nameof(Card.Rarity) => false,
            nameof(Card.Amounts) => false,
            _ => true
        };

        IOrderedQueryable<Card> PrimaryOrder<T>(Expression<Func<Card, T>> property)
        {
            return isAscending ^ filters.IsReversed
                ? cards.OrderBy(property)
                : cards.OrderByDescending(property);
        }

        return filters.OrderBy switch
        {
            nameof(Card.ManaCost) => 
                PrimaryOrder(c => c.Cmc)
                    .ThenBy(c => c.Name)
                    .ThenBy(c => c.SetName)
                    .ThenBy(c => c.Id),

            nameof(Card.SetName) =>
                PrimaryOrder(c => c.SetName)
                    .ThenBy(c => c.Name)
                    .ThenBy(c => c.Id),

            nameof(Card.Amounts) => 
                PrimaryOrder(c => c.Amounts.Sum(a => a.NumCopies))
                    .ThenBy(c => c.Name)
                    .ThenBy(c => c.SetName)
                    .ThenBy(c => c.Id),

            nameof(Card.Rarity) => 
                PrimaryOrder(c => c.Rarity)
                    .ThenBy(c => c.Name)
                    .ThenBy(c => c.SetName)
                    .ThenBy(c => c.Id),

            nameof(Card.Name) or _ =>
                PrimaryOrder(c => c.Name)
                    .ThenBy(c => c.SetName)
                    .ThenBy(c => c.Id)
        };
    }


    private static Task<Dictionary<string, int>> CardAmountsAsync(
        CardDbContext dbContext, 
        IEnumerable<Card> cards,
        CancellationToken cancel)
    {
        var cardIds = cards
            .Select(c => c.Id)
            .ToArray();

        return dbContext.Amounts
            .Where(a => cardIds.Contains(a.CardId))
            .GroupBy(a => a.CardId,
                (CardId, amounts) =>
                    new { CardId, Total = amounts.Sum(a => a.NumCopies) })

            .ToDictionaryAsync(
                ct => ct.CardId, ct => ct.Total, cancel);
    }

    #endregion

}
