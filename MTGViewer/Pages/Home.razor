@page "/"
@implements IDisposable

@inject IDbContextFactory<CardDbContext> DbFactory
@inject PageSizes PageSizes
@inject ILogger<Home> Logger


<PageTitle> MTG Viewer </PageTitle>

<h1 class="text-center display-4">Welcome to the card database!</h1>

<section class="pt-4">
    @if (IsEmptyCollection)
    {
        <h3> Currently, there are no cards in the collection. </h3>
    }
    else
    {
        <h3>
            <a href="/Cards" title="Card Collection">
                Cards from our collection!  </a>
        </h3>

        <div class="row no-gutters justify-content-center">
            @foreach (var card in RandomCards)
            {
                <a href="/Cards/Details/@card.Id" class="col-md-3 col-6"
                    title="@card.Name Details"
                    aria-label="@card.Id details">

                    <img alt="@card.Name image" 
                        class="w-100 img-fluid rounded" 
                        src="@card.ImageUrl.WithHttps()">
                </a>
            }
        </div>

        <div class="pt-3 d-flex justify-content-center">
            <button title="More Cards" type="button" class="btn btn-secondary"
                @onclick="LoadMoreCardsAsync" 
                disabled="@(IsBusy || IsFullyLoaded)" >
                @if (IsBusy)
                {
                    <text>
                        <span class="spinner-border spinner-border-sm"
                            role="status" aria-hidden="true"> </span>
                        Loading...
                    </text>
                }
                else
                {
                    <text> Load More </text>
                }
            </button>
        </div>
    }
</section>

@if (RecentChanges.Any())
{
    <section class="pt-5">
        <h3>
            <a href="/Treasury/History" title="Treasury History">
                Recent Shared Collection Changes </a>
        </h3>

        <ul class="list-group list-group-flush">
            @foreach (var transaction in RecentChanges)
            {
                var changes = transaction.Changes;
                var adds = changes.Where(c => c.To is Box);
                var removes = changes.Where(c => c.From is Box);

                <li class="list-group-item">
                    <div class="row justify-content-between">

                        <div class="col-md-10 col-9">
                            <div class="row align-items-center">
                                <div class="row-title ellipsis pr-2">
                                    @if (adds.Any())
                                    {
                                        <strong> Added </strong> @CardNames(adds)
                                    }
                                    else if (removes.Any())
                                    {
                                        <strong> Removed </strong> @CardNames(removes)
                                    }
                                    else
                                    {
                                        <text> No cards added </text>
                                    }
                                </div>
                                <span class="badge badge-secondary badge-pill">
                                    @changes.Sum(c => c.Amount) 
                                </span>
                            </div>
                        </div>

                        <div class="col d-flex align-items-center justify-content-end text-right">
                            <small class="text-muted"> @ElapsedTime(transaction) </small>
                        </div>
                    </div>
                </li>
            }
        </ul>
    </section>
}


@code
{
    private const int ChunkSize = 4;

    private readonly CancellationTokenSource _cancel = new();

    private bool _isBusy;
    private DateTime _currentTime;

    private RandomCardsContext? _randomContext;
    private IReadOnlyList<Transaction> _recentChanges = Array.Empty<Transaction>();


    public bool IsBusy => _isBusy;

    public bool IsFullyLoaded => !_randomContext?.HasMore ?? true;

    public bool IsEmptyCollection => !_randomContext?.Cards.Any() ?? false;

    public IReadOnlyList<Card> RandomCards => _randomContext?.Cards ?? Array.Empty<Card>();

    public IReadOnlyList<Transaction> RecentChanges => _recentChanges;


    protected override async Task OnInitializedAsync()
    {
        if (_isBusy)
        {
            return;
        }

        _isBusy = true;

        try
        {
            var cancelToken = _cancel.Token;
            int loadLimit = PageSizes.Limit;

            await using var dbContext = await DbFactory.CreateDbContextAsync(cancelToken);

            _randomContext = await RandomCardsContext.CreateAsync(dbContext, loadLimit, cancelToken);

            _recentChanges = await RecentTransactionsAsync(dbContext, cancelToken);

            _currentTime = DateTime.UtcNow;
        }
        catch (OperationCanceledException ex)
        {
            Logger.LogError(ex.ToString());
        }
        finally
        {
            _isBusy = false;
        }
    }


    public void Dispose()
    {
        _cancel.Cancel();
        _cancel.Dispose();
    }



    public static string CardNames(IEnumerable<Change> changes)
    {
        var cardNames = changes
            .GroupBy(c => c.Card.Name, (name, _) => name);

        return string.Join(", ", cardNames);
    }


    public string ElapsedTime(Transaction transaction)
    {
        var elapsed = _currentTime - transaction.AppliedAt;

        return elapsed switch
        {
            { Days: >0 } => $"{elapsed.Days} days ago",
            { Hours: >0 } => $"{elapsed.Hours} hours ago",
            { Minutes: >0 } => $"{elapsed.Minutes} min ago",
            _ => $"{elapsed.Seconds} sec ago"
        };
    }


    public async Task LoadMoreCardsAsync()
    {
        if (_isBusy || _randomContext is null || !_randomContext.HasMore)
        {
            return;
        }

        _isBusy = true;
        
        try
        {
            var cancelToken = _cancel.Token;

            await using var dbContext = await DbFactory.CreateDbContextAsync(cancelToken);

            dbContext.Cards.AttachRange(_randomContext.Cards);

            await _randomContext.LoadNextChunkAsync(dbContext, cancelToken);
        }
        catch (OperationCanceledException ex)
        {
            Logger.LogError(ex.ToString());
        }
        finally
        {
            _isBusy = false;
        }
    }


    private class RandomCardsContext
    {
        private readonly List<Card> _cards;
        private readonly IReadOnlyList<string[]> _loadOrder;
        private readonly int _limit;

        public IReadOnlyList<Card> Cards => _cards;
        public bool HasMore => _cards.Count < _limit;


        private RandomCardsContext(IReadOnlyList<string[]> loadOrder)
        {
            _cards = new();
            _loadOrder = loadOrder;
            _limit = _loadOrder.Sum(chunk => chunk.Length);
        }


        public static async Task<RandomCardsContext> CreateAsync(
            CardDbContext dbContext, 
            int loadLimit, 
            CancellationToken cancel)
        {
            var loadOrder = await ShuffleOrderAsync(dbContext, loadLimit, cancel);
            var randomContext = new RandomCardsContext(loadOrder);

            if (randomContext.HasMore)
            {
                await randomContext.LoadNextChunkAsync(dbContext, cancel);
            }

            return randomContext;
        }

        public async Task LoadNextChunkAsync(CardDbContext dbContext, CancellationToken cancel)
        {
            if (dbContext is null)
            {
                throw new ArgumentNullException(nameof(dbContext));
            }

            var nextChunk = HasMore 
                ? _loadOrder[_cards.Count / ChunkSize] 
                : null;

            if (nextChunk is null)
            {
                throw new InvalidOperationException("Cannot load any more chunks");
            }

            _cards.AddRange( await CardChunkAsync(dbContext, nextChunk, cancel) );
        }
    }



    #region Database Queries

    private static Task<List<string[]>> ShuffleOrderAsync(
        CardDbContext dbContext,
        int limit,
        CancellationToken cancel)
    {
        return dbContext.Cards
            .Select(c => c.Id)
            .OrderBy(_ => EF.Functions.Random())
            .Take(limit)

            .AsNoTracking()
            .AsAsyncEnumerable()
            .Chunk(ChunkSize)

            .ToListAsync(cancel)
            .AsTask();
    }


    private static ValueTask<List<Card>> CardChunkAsync(
        CardDbContext dbContext, 
        string[] chunk,
        CancellationToken cancel)
    {
        var chunkCards = dbContext.Cards
            .Where(c => chunk.Contains(c.Id))
            .AsNoTracking()
            .AsAsyncEnumerable();

        // preserve order of chunk
        return chunk
            .ToAsyncEnumerable()
            .Join(chunkCards,
                cid => cid,
                c => c.Id,
                (_, card) => card)
            .ToListAsync(cancel);
    }


    private static Task<List<Transaction>> RecentTransactionsAsync(
        CardDbContext dbContext,
        CancellationToken cancel)
    {
        return dbContext.Transactions
            .Where(t => t.Changes
                .Any(c => c.To is Deck && c.From is Box
                    || c.To is Box && (c.From == null || c.From is Deck)))

            .Include(t => t.Changes
                .Where(c => c.To is Deck && c.From is Box
                    || c.To is Box && (c.From == null || c.From is Deck))
                .OrderBy(c => c.Card.Name))

            .Include(t => t.Changes)
                .ThenInclude(c => c.Card)

            .Include(t => t.Changes)
                .ThenInclude(c => c.From)

            .Include(t => t.Changes)
                .ThenInclude(c => c.To)

            .OrderByDescending(t => t.AppliedAt)
                .ThenBy(t => t.Id)

            .Take(ChunkSize)
            .AsNoTrackingWithIdentityResolution()
            .ToListAsync(cancel);
    }

    #endregion
}
