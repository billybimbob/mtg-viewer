@page "/"
@implements IDisposable

@using Microsoft.Extensions.Configuration

@inject IDbContextFactory<CardDbContext> DbFactory
@inject FixedCache Cache
@inject IConfiguration Config
@inject ILogger<Home> Logger


<PageTitle> MTG Viewer </PageTitle>

<h1 class="text-center display-4">Welcome to the card database!</h1>

<div class="pt-4">
    <a href="/Cards" title="Card Collection">
        <h3>Cards from our collection!</h3>
    </a>

    <div class="row no-gutters justify-content-center">
        @foreach (var card in RandomCards)
        {
            <a href="/Cards/Details/@card.Id" class="col-md-3 col-6"
                title="@card.Name Details"
                aria-label="@card.Id details">

                <img alt="@card.Id image" 
                    class="w-100 img-fluid rounded" 
                    src="@card.ImageUrl.WithHttps()">
            </a>
        }
    </div>
</div>

<div class="pt-5">
    <a href="/Treasury/History" title="Treasury History">
        <h3>Recent Shared Collection Changes</h3>
    </a>

    <ul class="list-group list-group-flush">
        @foreach (var transaction in RecentChanges)
        {
            var changes = transaction.Changes;
            var adds = changes.Where(c => c.To is Box);
            var removes = changes.Where(c => c.From is Box);

            <li class="list-group-item">
                <div class="row justify-content-between">

                    <div class="col-md-10 col-9">
                        <div class="row align-items-center">
                            <div class="row-title ellipsis pr-2">
                                @if (adds.Any())
                                {
                                    <strong> Added </strong> @CardNames(adds)
                                }
                                else if (removes.Any())
                                {
                                    <strong> Removed </strong> @CardNames(removes)
                                }
                                else
                                {
                                    <text> No cards added </text>
                                }
                            </div>
                            <span class="badge badge-secondary badge-pill">
                                @changes.Sum(c => c.Amount) 
                            </span>
                        </div>
                    </div>

                    <div class="col d-flex align-items-center justify-content-end">
                        <small class="text-muted"> @ElapsedTime(transaction) </small>
                    </div>
                </div>
            </li>
        }
    </ul>
</div>


@code {

    public IReadOnlyList<Card> RandomCards => _randomCards;

    public IReadOnlyList<Transaction> RecentChanges => _recentChanges;

    private readonly CancellationTokenSource _cancel = new();

    private bool _isBusy;
    private DateTime _currentTime;

    private IReadOnlyList<Card> _randomCards = Array.Empty<Card>();
    private IReadOnlyList<Transaction> _recentChanges = Array.Empty<Transaction>();


    private string CardNames(IEnumerable<Change> changes)
    {
        var cardNames = changes
            .GroupBy(c => c.Card.Name, (name, _) => name);

        return string.Join(", ", cardNames);
    }


    private string ElapsedTime(Transaction transaction)
    {
        var elapsed = _currentTime - transaction.AppliedAt;

        return elapsed switch
        {
            { Days: >0 } => $"{elapsed.Days} days ago",
            { Hours: >0 } => $"{elapsed.Hours} hours ago",
            { Minutes: >0 } => $"{elapsed.Minutes} min ago",
            _ => $"{elapsed.Seconds} sec ago"
        };
    }


    protected override async Task OnInitializedAsync()
    {
        if (_isBusy)
        {
            return;
        }

        _isBusy = true;

        try
        {
            var cancelToken = _cancel.Token;
            var numberOfCards = Config.GetValue("NumberOfCards", 8);
            var numberOfChanges = Config.GetValue("NumberOfChanges", 5);

            await using var dbContext = await DbFactory.CreateDbContextAsync(cancelToken);

            _randomCards = await Cache
                .GetOrCreateAsync(nameof(_randomCards), () => 
                    ShuffledCardsAsync(dbContext, numberOfCards, cancelToken));

            _recentChanges = await Cache
                .GetOrCreateAsync(nameof(_recentChanges), () =>
                    RecentTransactionsAsync(dbContext, numberOfChanges, cancelToken));

            _currentTime = DateTime.Now;
        }
        catch (OperationCanceledException ex)
        {
            Logger.LogError(ex.ToString());
        }
        finally
        {
            _isBusy = false;
        }
    }


    public void Dispose()
    {
        _cancel.Cancel();
        _cancel.Dispose();
    }


    private static Task<List<Card>> ShuffledCardsAsync(
        CardDbContext dbContext, 
        int numberOfCards,
        CancellationToken cancel)
    {
        return dbContext.Cards
            .OrderBy(_ => EF.Functions.Random())
            .Take(numberOfCards)
            .ToListAsync(cancel);
    }


    private static Task<List<Transaction>> RecentTransactionsAsync(
        CardDbContext dbContext,
        int numberOfChanges,
        CancellationToken cancel)
    {
        return dbContext.Transactions
            .Where(t => t.Changes.Any(c => c.To is Box || c.From is Box))

            .Include(t => t.Changes)
                .ThenInclude(c => c.Card)

            .Include(t => t.Changes)
                .ThenInclude(c => c.From)

            .Include(t => t.Changes)
                .ThenInclude(c => c.To)

            .Include(t => t.Changes
                .Where(c => c.To is Box || c.From is Box)
                .OrderBy(c => c.Card.Name))

            .OrderByDescending(t => t.AppliedAt)
            .Take(numberOfChanges)

            // no split query to avoid extra round trips
            // also Transactions has very few props
            .ToListAsync(cancel);
    }
}
