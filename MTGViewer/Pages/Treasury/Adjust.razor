@page "/Treasury/Adjust/{BoxId:int?}"
@attribute [Authorize]
@implements IDisposable

@using System.ComponentModel.DataAnnotations
@using MTGViewer.Data.Internal

@inject FixedCache Cache
@inject TreasuryHandler TreasuryHandler
@inject IDbContextFactory<CardDbContext> DbFactory

@inject NavigationManager Nav
@inject ILogger<Adjust> Logger


<PageTitle>
    @if (Box.IsEdit)
    {
        <text> Edit @Box.Name </text>
    }
    else
    {
        <text> Add New Box </text>
    }
</PageTitle>

<h1>
    @if (Box.IsEdit)
    {
        <text> Edit <a href="/Treasury/Details/@Box.Id"> @Box.Name </a> </text>
    }
    else
    {
        <text> Add New Box </text>
    }
</h1>
<hr />

<SavePrompt @bind-Result="_result">
    <SuccessMessage>
        @if (Box.IsEdit)
        {
            <text> @Box.Name was successfully updated. </text>
        }
        else
        {
            <text> New box was successfully added. </text>
        }
    </SuccessMessage>
    <ErrorMessage>
        Ran into issues while try to
        @if (Box.IsEdit)
        {
            <text> update @Box.Name </text>
        }
        else
        {
            <text> add a new Box. </text>
        }
    </ErrorMessage>
</SavePrompt>

<EditForm Model="@Box" OnValidSubmit="ValidBoxSubmittedAsync">
    <ObjectGraphDataAnnotationsValidator />

    <div class="row">
        <div class="col-12 col-md-8 col-lg-5 order-lg-last">
            <ValidationSummary role="alert" />
        </div>

        <div class="col col-md-8 col-lg-4">

            <div class="form-group">
                <label for="@BoxPropertyId(b => b.Name)">
                    @Box.DisplayName(b => b.Name)
                </label>
                <InputText @bind-Value="Box.Name" 
                    id="@BoxPropertyId(b => b.Name)" class="form-control" />
            </div>

            <div class="form-group">
                <label for="@BoxPropertyId(b => b.Bin)">
                    @Box.DisplayName(b => b.Bin)
                </label>
                <select @onchange="BinSelected" id="@BoxPropertyId(b => b.Bin)" class="form-control">
                    <option value="0" selected="@(!Box.Bin.IsEdit)"> Create New </option>

                    @foreach (var bin in Bins)
                    {
                        <option value="@bin.Id" selected="@(bin.Id == Box.Bin.Id)"> @bin.Name </option>
                    }
                </select>
            </div>

            <div class="form-group">
                <label for="@BinPropertyId(b => b.Name)">
                    @if (!Box.Bin.IsEdit)
                    {
                        <text>
                            New @Box.DisplayName(b => b.Bin) @Box.Bin.DisplayName(b => b.Name)
                        </text>
                    }
                    else if (Box.IsEdit)
                    {
                        <text>
                            Edit @Box.Bin.Name's @Box.Bin.DisplayName(b => b.Name)
                        </text>
                    }
                    else
                    {
                        <text>
                            @Box.DisplayName(b => b.Bin) @Box.Bin.DisplayName(b => b.Name)
                        </text>
                    }
                </label>
                <input value="@Box.Bin.Name" @onchange="BinNameChanged"
                    readonly="@(!Box.IsEdit && Box.Bin.IsEdit)"
                    id="@BinPropertyId(b => b.Name)" class="form-control" />
            </div>

            <div class="form-group">
                <label for="@BoxPropertyId(b => b.Appearance)">
                    @Box.DisplayName(b => b.Appearance)
                </label>
                <InputTextArea @bind-Value="Box.Appearance"
                    id="@BoxPropertyId(b => b.Appearance)" class="form-control" />
            </div>


            <div class="form-group">
                <label for="@BoxPropertyId(b => b.Capacity)">
                    @Box.DisplayName(b => b.Capacity)
                </label>
                <InputNumber @bind-Value="Box.Capacity" min=0
                    id="@BoxPropertyId(b => b.Capacity)" class="form-control" />
            </div>

            <div class="btn-group" role="group">
                <button class="btn btn-secondary" type="submit" disabled="@IsBusy">
                    @if (IsBusy)
                    {
                        <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"> </span>
                    }
                    @if (Box.IsEdit)
                    {
                        <text> Update </text>
                    }
                    else
                    {
                        <text> Add </text>
                    }
                </button>
            </div>
        </div>
    </div>
</EditForm>


@code
{
    [Parameter]
    public int BoxId { get; set; } = default;

    public BoxDto Box { get; } = new();
    public IReadOnlyList<Bin> Bins => _bins;

    public bool IsBusy => _dbBusy;


    private readonly CancellationTokenSource _cancel = new();

    private bool _dbBusy;
    private SaveResult _result;

    private Bin[] _bins = Array.Empty<Bin>();


    public sealed class BoxDto
    {
        public int Id { get; set; }

        public bool IsEdit => Id != default;

        [Required(ErrorMessage = "Box Name is Missing")]
        [StringLength(20, ErrorMessage = "Box Name has a character limit of 20")]
        public string? Name { get; set; }

        [StringLength(40, ErrorMessage = "Appearance has a character limit of 40")]
        public string? Appearance{ get; set; }

        [Range(10, 10_000, ErrorMessage = "Capacity must be Between 10 and 10,000")]
        public int Capacity { get; set; }

        [ValidateComplexType]
        public BinDto Bin { get; } = new();
    }


    public sealed class BinDto
    {
        public int Id { get; set; }

        [Required(ErrorMessage = "Bin Name is Missing")]
        [StringLength(10, ErrorMessage = "Bin Name has a character limit of 10")]
        public string? Name { get; set; }

        public bool IsEdit => Id != default;
    }



    protected override async Task OnInitializedAsync()
    {
        if (_dbBusy)
        {
            return;
        }

        _dbBusy = true;

        try
        {
            var cancelToken = _cancel.Token;

            await using var dbContext = await DbFactory.CreateDbContextAsync(cancelToken);

            _bins = await Cache
                .GetOrCreateAsync(nameof(_bins), () =>
                    BinOptionsAsync(dbContext, cancelToken));
        }
        catch (OperationCanceledException e)
        {
            Logger.LogWarning(e.ToString());
        }
        finally
        {
            _dbBusy = false;
        }
    }


    private static Task<Bin[]> BinOptionsAsync(CardDbContext dbContext, CancellationToken cancel)
    {
        return dbContext.Bins
            .Where(b => !b.Boxes.Any(box => box.IsExcess))
            .OrderBy(b => b.Name)
            .AsNoTracking()
            .ToArrayAsync(cancel);
    }


    protected override async Task OnParametersSetAsync()
    {
        if (_dbBusy)
        {
            return;
        }
        
        if (BoxId == default)
        {
            return;
        }

        _dbBusy = true;

        try
        {
            var cancelToken = _cancel.Token;

            await using var dbContext = await DbFactory.CreateDbContextAsync(cancelToken);

            var box = await Cache
                .GetOrCreateAsync($"{nameof(Box)}{BoxId}", () =>
                    ExistingBoxAsync(dbContext, BoxId, _bins, cancelToken));

            if (box != null)
            {
                Box.Id = box.Id;
                Box.Name = box.Name;

                Box.Appearance = box.Appearance;
                Box.Capacity = box.Capacity;

                Box.Bin.Id = box.Bin.Id;
                Box.Bin.Name = box.Bin.Name;
            }
        }
        catch (OperationCanceledException e)
        {
            Logger.LogWarning(e.ToString());
        }
        finally
        {
            _dbBusy = false;
        }
    }


    private static Task<Box?> ExistingBoxAsync(
        CardDbContext dbContext, int id, IEnumerable<Bin> bins, CancellationToken cancel)
    {
        dbContext.Bins.AttachRange(bins);

        return dbContext.Boxes
            .Include(b => b.Bin)
            .SingleOrDefaultAsync(b => !b.IsExcess && b.Id == id, cancel);
    }
    

    public void Dispose()
    {
        _cancel.Cancel();
        _cancel.Dispose();
    }



    public static string BoxPropertyId<T>(Expression<Func<BoxDto, T>> property)
    {
        if (property.Body is not MemberExpression expression)
        {
            return string.Empty;
        }

        return $"{nameof(BoxDto)}-{expression.Member.Name}";
    }


    public static string BinPropertyId<T>(Expression<Func<BinDto, T>> property)
    {
        if (property.Body is not MemberExpression expression)
        {
            return string.Empty;
        }

        return $"{nameof(BinDto)}-{expression.Member.Name}";
    }



    public async Task ValidBoxSubmittedAsync()
    {
        if (_dbBusy || Box.Name is null || Box.Bin.Name is null)
        {
            return;
        }

        _dbBusy = true;

        try
        {
            _result = SaveResult.None;

            var cancelToken = _cancel.Token;
            await using var dbContext = await DbFactory.CreateDbContextAsync(cancelToken);

            var box = new Box
            {
                Id = Box.Id,
                Name = Box.Name,

                Appearance = Box.Appearance,
                Capacity = Box.Capacity,

                Bin = new Bin
                {
                    Id = Box.Bin.Id,
                    Name = Box.Bin.Name
                }
            };

            dbContext.Update(box);

            await TreasuryHandler.UpdateAsync(dbContext, box, cancelToken);

            await dbContext.SaveChangesAsync(cancelToken);

            _result = SaveResult.Success;

            Nav.NavigateTo("/Treasury/", true);
        }

        catch (DbUpdateException e)
        {
            _result = SaveResult.Error;

            Logger.LogError(e.ToString());
        }
        catch (OperationCanceledException e)
        {
            _result = SaveResult.Error;

            Logger.LogWarning(e.ToString());
        }

        finally
        {
            _dbBusy = false;
        }
    }


    public void BinSelected(ChangeEventArgs args)
    {
        if (!int.TryParse(args.Value?.ToString(), out int binId))
        {
            return;
        }

        var bin = _bins.SingleOrDefault(b => b.Id == binId);
        var binDto = Box.Bin;

        if (bin == default)
        {
            binDto.Id = default;
            binDto.Name = null;
        }
        else
        {
            binDto.Id = bin.Id;
            binDto.Name = bin.Name;
        }
    }


    public void BinNameChanged(ChangeEventArgs args)
    {
        var newName = args.Value?.ToString();

        if (Box.IsEdit || !Box.Bin.IsEdit)
        {
            Box.Bin.Name = newName;
        }
    }
}