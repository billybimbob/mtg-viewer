@using MTGViewer.Data
@using MTGViewer.Data.Concurrency
@using MTGViewer.Areas.Identity.Data
@using Microsoft.EntityFrameworkCore.ChangeTracking

@namespace MTGViewer.Components
@implements IDisposable

@inject NavigationManager NavigationManager
@inject IDbContextFactory<MTGCardContext> DbFactory
@inject ILogger<DeckBuilder> Logger


<h1>Deck Builder</h1>

<button title="Save Deck"
        type="button"
        class="btn btn-secondary"
        @onclick="CommitChangesAsync">
    Save Changes
</button>

<h2>Available Cards</h2>

<table class="table">
    <thead>
        <tr>
            <th>Card Name</th>
            <th>Mana Cost</th>
            <th>Set</th>
            <th>Rarity</th>
            <th>Amount Available</th>
            <th></th>
        </tr>
    </thead>

    <tbody>
        @foreach (var card in _dbCards.Values)
        {
            var available = _availables[card.Id].Amount;
            <tr>
                <td class="fw-bold">@card.Name</td>

                <td>
                    @foreach (var cost in card.GetColorSymbols())
                    {
                        <span class="m-1 ms ms-@cost.ToLower() ms-cost"></span>
                    }
                </td>

                <td>@card.SetName</td>
                <td>@card.Rarity</td>
                <td>@available</td>

                <td>
                    <button title="@card.Name Add"
                            type="button"
                            class="btn btn-outline-secondary border-0 rounded"
                            disabled="@(available==0)"
                            @onclick="() => AddCardToDeck(card)">
                        Add Card
                    </button>
                </td>
            </tr>
        }
    </tbody>
</table>


<input @bind="_deck.Name" class="form-control form-control-lg border-0"/>

<table class="table mt-2">
    <thead>
        <tr>
            <th>Card Name</th>
            <th>Mana Cost</th>
            <th>Set</th>
            <th>Deck Amount</th>
            <th></th>
        </tr>
    </thead>

    <tbody>
        @foreach (var card in _dbCards.Values)
        {
            @if (_deckCards.TryGetValue(card.Id, out var inDeck)
                && inDeck.Amount > 0)
            {
                <tr>
                    <td class="fw-bold">@card.Name</td>

                    <td>
                        @foreach (var cost in card.GetColorSymbols())
                        {
                            <span class="m-1 ms ms-@cost.ToLower() ms-cost"></span>
                        }
                    </td>

                    <td>@card.SetName</td>
                    <td>@inDeck.Amount</td>

                    <td>
                        <button title="@card.Name Remove"
                                type="button"
                                class="btn btn-outline-secondary border-0 rounded"
                                @onclick="() => RemoveCardFromDeck(card)">
                            Remove Card
                        </button>
                    </td>
                </tr>
            }
        }
    </tbody>
</table>


@code {

    [Parameter]
    public CardUser User { get; set; }

    [Parameter]
    public int DeckId { get; set; } = default;


    private bool _busy;
    private MTGCardContext _context;

    private Location _deck;
    private SortedList<string, Card> _dbCards;

    private IDictionary<string, CardAmount> _deckCards;
    private IDictionary<string, CardAmount> _availables;


    protected override async Task OnInitializedAsync()
    {
        if (_busy)
        {
            return;
        }

        _busy = true;
        _context = DbFactory.CreateDbContext();

        _dbCards = new SortedList<string, Card>(
            await _context.Cards.ToDictionaryAsync(c => c.Name));

        _availables = await _context.Amounts
            .Where(ca => ca.Location.OwnerId == default)
            // TODO: change return location
            // TODO: group amounts by cards
            // .GroupBy(ca => ca.CardId)
            .ToDictionaryAsync(ca => ca.CardId);

        _busy = false;
    }


    protected override async Task OnParametersSetAsync()
    {
        _deck = await GetOrCreateDeckAsync();
        _deckCards = _deck.Cards.ToDictionary(c => c.CardId);

        // TODO: change amounts to include request amounts
    }


    private async Task<Location> GetOrCreateDeckAsync()
    {
        if (DeckId != default)
        {
            return await _context.Locations
                .Include(l => l.Cards)
                .SingleAsync(l => l.Id == DeckId);
        }

        var userDeckCount = await _context.Locations
            .Where(l => l.Owner == User)
            .CountAsync();

        var newLoc = new Location(
            name: $"Deck #{userDeckCount + 1}") {
            Owner = User
        };

        _context.Attach(newLoc);

        return newLoc;
    }


    private void AddCardToDeck(Card card)
    {
        if (!_availables.TryGetValue(card.Id, out var availAmnt))
        {
            Logger.LogError($"card {card.Id} is not a listed avaliable card");
            return;
        }

        if (availAmnt.Amount == 0)
        {
            Logger.LogError($"there are no more available {card.Id} cards to add");
            // could maybe handle this "overdraft" error differently
            return;
        }

        availAmnt.Amount -= 1;

        if (_deckCards.TryGetValue(card.Id, out var deckAmnt))
        {
            deckAmnt.Amount += 1;
        }
        else
        {
            var newAmnt = new CardAmount
            {
                Card = card,
                Amount = 1,
                Location = _deck,
                // IsRequest = true
                // not sure when to set request
            };

            _context.Attach(newAmnt);
            _deckCards.Add(card.Id, newAmnt);
        }
    }


    private void RemoveCardFromDeck(Card card)
    {
        if (!_availables.TryGetValue(card.Id, out var availAmnt))
        {
            Logger.LogError($"card {card.Id} does exist in available set");
            return;
        }

        if (!_deckCards.TryGetValue(card.Id, out var deckAmnt))
        {
            Logger.LogError($"card {card.Id} is not in the deck");
            return;
        }

        if (deckAmnt.Amount == 0)
        {
            Logger.LogError($"there are no more of {card.Id} to remove");
            return;
        }

        availAmnt.Amount += 1;

        deckAmnt.Amount -= 1;
    }



    private async Task CommitChangesAsync()
    {
        if (_busy)
        {
            return;
        }

        _busy = true;
        PrepareChanges();

        try {
            await _context.SaveChangesAsync();
            await UpdateAvailableAsync();

            Logger.LogInformation($"successfully updated, trying to nav to index, at {NavigationManager.BaseUri}");
            NavigationManager.NavigateTo("Cards/Index"); // TODO: fix nav not working
        }
        catch (DbUpdateConcurrencyException ex)
        {
            await UpdateDeckAsync(ex);
            await UpdateAvailableAsync();
        }
        finally
        {
            _busy = false;
        }
    }


    private void PrepareChanges()
    {
        foreach(var cardAmnt in _deck.Cards)
        {
            if (cardAmnt.Amount == 0)
            {
                _context.Remove(cardAmnt);
            }
        }

        var deckEntry = _context.Entry(_deck);
        if (deckEntry.State == EntityState.Unchanged)
        {
            deckEntry.State = EntityState.Modified;
        }
    }


    private async Task UpdateDeckAsync(DbUpdateConcurrencyException ex)
    {
        if (!HasDeckConflicts(ex))
        {
            return;
        }

        var dbCards = await _context.Amounts
            .Where(ca => ca.LocationId == _deck.Id)
            .AsNoTracking()
            .ToListAsync();

        MergeDeckRemoves(dbCards);

        foreach(var dbCard in dbCards)
        {
            if (!_deckCards.TryGetValue(dbCard.CardId, out var currentCard))
            {
                // ensure reference in set to tracked entity
                dbCard.Card = _availables[dbCard.CardId].Card;
                dbCard.Location = _deck;

                _deckCards.Add(dbCard.CardId, dbCard);
                _context.Attach(dbCard);
                continue;
            }

            var currEntry = _context.Entry(currentCard);

            if (currEntry.State == EntityState.Unchanged)
            {
                currentCard.Amount = dbCard.Amount;
            }
            else if (dbCard.Amount != currentCard.Amount)
            {
                // overriding conflict amount, so transferring 
                // back cancelled amount
                var originalAmnt = currEntry.Property(ca => ca.Amount).OriginalValue;
                var dbDeckChange = dbCard.Amount - originalAmnt;

                var availEntry = _context
                    .Entry(_availables[dbCard.CardId])
                    .Property(ca => ca.Amount);

                availEntry.OriginalValue -= dbDeckChange;
            }

            _context.MatchToken(currentCard, dbCard);
        }

        await _context.MatchToken(_deck);
    }


    private bool HasDeckConflicts(DbUpdateConcurrencyException ex)
    {
        var deckConflict = ex.Entries<Location>()
            .SingleOrDefault();

        if (deckConflict != null && deckConflict.Entity.Id == _deck.Id)
        {
            return true;
        }

        var conflictsInDeck = ex.Entries<CardAmount>()
            .Select(ca => ca.Entity.CardId)
            .Intersect(_deckCards.Keys);

        return conflictsInDeck.Any();
    }


    private void MergeDeckRemoves(IEnumerable<CardAmount> dbDeckCards)
    {
        var removedCards = _deckCards.Keys.Except(dbDeckCards.Select(ca => ca.CardId));

        foreach(var removedId in removedCards)
        {
            var currAmount = _deckCards[removedId];

            if (_context.Entry(currAmount).State == EntityState.Unchanged)
            {
                _context.Remove(currAmount);
                _deckCards.Remove(removedId);
            }
        }
    }


    private async Task UpdateAvailableAsync()
    {
        var updatedAvails = await _context.Amounts
            .Where(ca => ca.Location.OwnerId == default)
            // TODO: change return location
            // TODO: group amounts by cards
            // .GroupBy(ca => ca.CardId)
            .AsNoTracking()
            .ToListAsync();

        foreach(var dbAvail in updatedAvails)
        {
            dbAvail.Card = await _context.Cards.FindAsync(dbAvail.CardId);

            if (!_dbCards.ContainsKey(dbAvail.Card.Name))
            {
                _dbCards.Add(dbAvail.Card.Name, dbAvail.Card);
            }


            if (!_availables.TryGetValue(dbAvail.CardId, out var conflict))
            {
                _availables.Add(dbAvail.CardId, dbAvail);
                _context.Attach(dbAvail);
            }
            else if (conflict.Amount != dbAvail.Amount)
            {
                var amntProp = _context.Entry(conflict)
                    .Property(ca => ca.Amount);

                var availChange = amntProp.CurrentValue - amntProp.OriginalValue;

                conflict.Amount = dbAvail.Amount + availChange;
                _context.MatchToken(conflict, dbAvail);
            }
        }
    }


    public void Dispose()
    {
        _context?.Dispose();
    }

}