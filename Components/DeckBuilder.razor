@using MTGViewer.Data
@using MTGViewer.Data.Concurrency
@using MTGViewer.Areas.Identity.Data

@namespace MTGViewer.Components
@implements IDisposable

@inject NavigationManager NavigationManager
@inject IDbContextFactory<CardDbContext> DbFactory
@inject ILogger<DeckBuilder> Logger


<h1>Deck Builder</h1>

<button title="Save Deck"
        type="button"
        class="btn btn-secondary mb-3"
        disabled="@HasNoChanges"
        @onclick="CommitChangesAsync">
    Save Changes
</button>


@if (_result == SaveResult.Success)
{
    <div class="alert alert-success d-flex align-items-center alert-dismissible fade show" role="alert">
        <svg class="bi bi-check-circle-fill flex-shrink-0 mr-4" 
            viewBox="0 0 16 16"
            width="24"
            height="24"
            fill="currentColor"
            role="img"
            aria-label="Success:">
            <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zm-3.97-3.03a.75.75 0 0 0-1.08.022L7.477 9.417 5.384 7.323a.75.75 0 0 0-1.06 1.06L6.97 11.03a.75.75 0 0 0 1.079-.02l3.992-4.99a.75.75 0 0 0-.01-1.05z"/>
        </svg>
        <div>
            Save was succesful, and values have been updated
        </div>
        <button type="button" 
                class="close" 
                aria-label="Close Success"
                @onclick="() => _result = SaveResult.None">
            <span aria-hidden="true">&times;</span>
        </button>
    </div>
}
else if (_result == SaveResult.Error)
{
    <div class="alert alert-danger d-flex align-items-center alert-dismissible fade show" role="alert">
        <svg class="bi bi-exclamation-triangle-fill flex-shrink-0 mr-4"
            viewBox="0 0 16 16"
            width="24"
            height="24"
            fill="currentColor"
            role="img"
            aria-label="Danger:">
            <path d="M8.982 1.566a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98 1.767h13.713c.889 0 1.438-.99.98-1.767L8.982 1.566zM8 5c.535 0 .954.462.9.995l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 5.995A.905.905 0 0 1 8 5zm.002 6a1 1 0 1 1 0 2 1 1 0 0 1 0-2z"/>
        </svg>
        <div>
            <p>There are conflicts while trying to save, and values have been updated. </p>
            <hr>
            <p>Save again to confirm</p>
        </div>
        <button type="button" 
                class="close" 
                aria-label="Close Error"
                @onclick="() => _result = SaveResult.None">
            <span aria-hidden="true">&times;</span>
        </button>
    </div>
}


<h2>Available Cards</h2>

<table class="table">
    <thead>
        <tr>
            <th>Card Name</th>
            <th>Mana Cost</th>
            <th>Set</th>
            <th>Rarity</th>
            <th>Amount Available</th>
            <th></th>
        </tr>
    </thead>

    <tbody>
        @foreach (var card in SortedAvailCards)
        {
            var available = _availables[card.Id].Amount;
            <tr>
                <td class="fw-bold">@card.Name</td>

                <td>
                    @foreach (var cost in card.GetColorSymbols())
                    {
                        <span class="m-1 ms ms-@cost.ToLower() ms-cost"></span>
                    }
                </td>

                <td>@card.SetName</td>
                <td>@card.Rarity</td>
                <td>@available</td>

                <td>
                    <button title="@card.Name Add"
                            type="button"
                            class="btn btn-outline-secondary border-0 rounded"
                            disabled="@(available==0)"
                            @onclick="() => AddCardToDeck(card)">
                        Add Card
                    </button>
                </td>
            </tr>
        }
    </tbody>
</table>


<input @bind="_deck.Name" class="form-control form-control-lg border-0"/>

<table class="table mt-2">
    <thead>
        <tr>
            <th>Card Name</th>
            <th>Mana Cost</th>
            <th>Set</th>
            <th>Deck Amount</th>
            <th>Requests</th>
            <th></th>
        </tr>
    </thead>

    <tbody>
        @foreach (var card in SortedDeckCards)
        {
            var inDeck = _deckCards[card.Id];
            <tr>
                <td class="fw-bold">@card.Name</td>

                <td>
                    @foreach (var cost in card.GetColorSymbols())
                    {
                        <span class="m-1 ms ms-@cost.ToLower() ms-cost"></span>
                    }
                </td>

                <td>@card.SetName</td>

                <td>@inDeck.Applied.Amount</td>
                <td>@(inDeck.Request?.Amount ?? 0)</td>

                <td>
                    <button title="@card.Name Remove"
                            type="button"
                            class="btn btn-outline-secondary border-0 rounded"
                            @onclick="() => RemoveCardFromDeck(card)">
                        Remove Card
                    </button>
                </td>
            </tr>
        }
    </tbody>
</table>


@code {

    [Parameter]
    public CardUser User { get; set; }

    [Parameter]
    public int DeckId { get; set; } = default;


    private bool _busy;
    private SaveResult _result;
    private CardDbContext _context;

    private Location _deck;
    private SortedList<string, List<Card>> _dbCards;

    private IDictionary<string, AmountGroup> _deckCards;
    private IDictionary<string, CardAmount> _availables;


    private bool HasNoChanges =>
        !_context.ChangeTracker.HasChanges();

    private IEnumerable<Card> SortedAvailCards =>
        _dbCards.Values
            .SelectMany(l => l);

    private IEnumerable<Card> SortedDeckCards =>
        SortedAvailCards
            .Where(c => _deckCards.TryGetValue(c.Id, out var cardAmnt)
                && cardAmnt.Amount > 0);


    protected override async Task OnInitializedAsync()
    {
        if (_busy)
        {
            return;
        }

        _busy = true;
        _context = DbFactory.CreateDbContext();

        var cards = await _context.Cards.ToListAsync();

        var nameGroups = cards
            .GroupBy(c => c.Name)
            .ToDictionary(g => g.Key, g => g.ToList());

        _dbCards = new SortedList<string, List<Card>>(nameGroups);

        _availables = await _context.Amounts
            .Where(ca => ca.Location.OwnerId == default)
            // TODO: change return location
            // TODO: group amounts by cards
            // .GroupBy(ca => ca.CardId)
            .ToDictionaryAsync(ca => ca.CardId);

        _busy = false;
        _result = SaveResult.None;
    }


    protected override async Task OnParametersSetAsync()
    {
        _deck = await GetOrCreateDeckAsync();

        _deckCards = _deck.Cards
            .GroupBy(ca => ca.CardId)
            .ToDictionary(g => g.Key, InitGroup);

        FixDeckState();
    }


    private async Task<Location> GetOrCreateDeckAsync()
    {
        if (DeckId != default)
        {
            return await _context.Locations
                .Include(l => l.Cards)
                .SingleAsync(l => l.Id == DeckId);
        }

        var userDeckCount = await _context.Locations
            .Where(l => l.Owner == User)
            .CountAsync();

        var newLoc = new Location($"Deck #{userDeckCount + 1}")
        {
            Owner = User
        };

        _context.Attach(newLoc);

        return newLoc;
    }


    private AmountGroup InitGroup(IGrouping<string, CardAmount> grouping)
    {
        if (!grouping.Any())
        {
            throw new System.ArgumentException("Grouping is empty");
        }

        var applied = grouping.SingleOrDefault(ca => !ca.IsRequest);
        var request = grouping.SingleOrDefault(ca => ca.IsRequest);

        if (applied == null)
        {
            applied = new CardAmount
            {
                Card = request.Card,
                Location = request.Location,
                Amount = 0
            };

            _context.Add(applied);
        }

        return new AmountGroup(applied, request);
    }


    public void Dispose()
    {
        _context?.Dispose();
    }


    private void AddCardToDeck(Card card)
    {
        CardAmount availAmnt;
        
        if (!_availables.TryGetValue(card.Id, out availAmnt))
        {
            Logger.LogError($"card {card.Id} is not a listed avaliable card");
            return;
        }

        AmountGroup deckGroup;

        if (!_deckCards.TryGetValue(card.Id, out deckGroup))
        {
            var newAmnt = new CardAmount
            {
                Card = card,
                Location = _deck,
                Amount = 0,
            };

            deckGroup = new AmountGroup(newAmnt);

            _deckCards.Add(card.Id, deckGroup);
            _context.Add(newAmnt);
        }

        deckGroup.Applied.Amount += 1;
        availAmnt.Amount -= 1;

        if (availAmnt.Amount < 0)
        {
            FixOverdraft(card);
        }

        _result = SaveResult.None;
    }


    private void RemoveCardFromDeck(Card card)
    {
        CardAmount availAmnt;

        if (!_availables.TryGetValue(card.Id, out availAmnt))
        {
            Logger.LogError($"card {card.Id} does exist in available set");
            return;
        }

        AmountGroup deckAmnt;

        if (!_deckCards.TryGetValue(card.Id, out deckAmnt))
        {
            Logger.LogError($"card {card.Id} is not in the deck");
            return;
        }

        if (deckAmnt.Request?.Amount > 0)
        {
            deckAmnt.Request.Amount -= 1;
            return;
        }

        if (deckAmnt.Applied.Amount == 0)
        {
            Logger.LogError($"there are no more of {card.Id} to remove");
            return;
        }

        deckAmnt.Applied.Amount -= 1;
        availAmnt.Amount += 1;

        _result = SaveResult.None;
    }



    private void FixOverdraft(Card card)
    {
        CardAmount availAmnt;

        if (!_availables.TryGetValue(card.Id, out availAmnt))
        {
            Logger.LogError($"{card.Id} does not exist in available");
            return;
        }

        AmountGroup deckGroup;

        if (!_deckCards.TryGetValue(card.Id, out deckGroup))
        {
            Logger.LogInformation($"{card.Id} does not exist in deck");
            return;
        }

        if (availAmnt.Amount < 0)
        {
            if (deckGroup.Request == null)
            {
                deckGroup.Request = new CardAmount
                {
                    Card = deckGroup.Card,
                    Location = deckGroup.Location,
                    IsRequest = true
                };

                _context.Add(deckGroup.Request);
            }

            // transfer overdraft to request
            deckGroup.Applied.Amount += availAmnt.Amount;
            deckGroup.Request.Amount -= availAmnt.Amount;
            availAmnt.Amount = 0;
        }

        else if (availAmnt.Amount > 0 && deckGroup.Request?.Amount > 0)
        {
            int changeAmnt = Math.Min(availAmnt.Amount, deckGroup.Request.Amount);

            deckGroup.Applied.Amount += changeAmnt;
            deckGroup.Request.Amount -= changeAmnt;
            availAmnt.Amount -= changeAmnt;
        }
    }


    private async Task CommitChangesAsync()
    {
        if (_busy)
        {
            return;
        }

        _busy = true;

        PrepareChanges();

        try {
            await _context.SaveChangesAsync();
            _result = SaveResult.Success;

            Logger.LogInformation($"successfully updated, trying to nav to index, at {NavigationManager.BaseUri}");
            NavigationManager.NavigateTo("Cards/Index"); // TODO: fix nav not working
        }
        catch (DbUpdateConcurrencyException ex)
        {
            _result = SaveResult.Error;
            await UpdateDeckAsync(ex);
        }
        finally
        {
            await UpdateAvailableAsync();

            FixDeckState();

            _busy = false;
        }
    }


    private void PrepareChanges()
    {
        foreach (var cardAmnt in _deckCards.Values.SelectMany(g => g))
        {
            // detaches when saved after a remove
            if (_context.Entry(cardAmnt).State == EntityState.Detached)
            {
                _context.Add(cardAmnt);
            }

            @* if (cardAmnt.Amount == 0)
            {
                _context.Remove(cardAmnt);
            } *@
            
        }

        var deckEntry = _context.Entry(_deck);

        if (deckEntry.State == EntityState.Unchanged)
        {
            deckEntry.State = EntityState.Modified;
        }
    }


    private void FixDeckState()
    {
        foreach (var cardGroup in _deckCards.Values)
        {
            FixOverdraft(cardGroup.Card);
        }
    }


    private async Task UpdateDeckAsync(DbUpdateConcurrencyException ex)
    {
        if (HasNoDeckConflicts(ex))
        {
            return;
        }

        var dbDeckCards = await _context.Amounts
            .Where(ca => ca.LocationId == _deck.Id)
            .AsNoTracking()
            .ToListAsync();

        MergeDeckRemoves(dbDeckCards);

        foreach (var dbCard in dbDeckCards)
        {
            MergeDeckCardConflict(dbCard);
        }

        foreach(var cardGroup in dbDeckCards.GroupBy(ca => ca.CardId))
        {
            await TrackNewCardAsync(cardGroup);
        }

        await _context.MatchToken(_deck);
    }


    private bool HasNoDeckConflicts(DbUpdateConcurrencyException ex)
    {
        var deckConflict = ex.Entries<Location>()
            .SingleOrDefault();

        if (deckConflict != null && deckConflict.Entity.Id == _deck.Id)
        {
            return false;
        }

        var conflictsInDeck = ex.Entries<CardAmount>()
            .Select(ca => ca.Entity.CardId)
            .Intersect(_deckCards.Keys);

        return !conflictsInDeck.Any();
    }


    private void MergeDeckRemoves(IEnumerable<CardAmount> dbDeckCards)
    {
        var dbCardIds = dbDeckCards
            .Select(ca => ca.CardId)
            .Distinct();

        var removedCards = _deckCards.Keys
            .Except(dbCardIds)
            .SelectMany(id => _deckCards[id]);

        foreach(var removedCard in removedCards)
        {
            if (_context.Entry(removedCard).State == EntityState.Unchanged)
            {
                _context.Remove(removedCard);
            }
        }
    }


    private void MergeDeckCardConflict(CardAmount dbDeckCard)
    {
        AmountGroup localDeckGroup;

        if (!_deckCards.TryGetValue(dbDeckCard.CardId, out localDeckGroup))
        {
            return;
        }

        var localDeckCard = dbDeckCard.IsRequest
            ? localDeckGroup.Request
            : localDeckGroup.Applied;

        if (localDeckCard == null)
        {
            dbDeckCard.Card = localDeckGroup.Card;
            dbDeckCard.Location = localDeckGroup.Location;

            // token also is matched
            localDeckGroup.Request = dbDeckCard;
            _context.Attach(dbDeckCard);

            return;
        }

        var currEntry = _context.Entry(localDeckCard);

        if (currEntry.State != EntityState.Unchanged)
        {
            // overriding conflict amount, so transferring 
            // back cancelled amount to available
            var lastReadAmnt = currEntry.Property(ca => ca.Amount).OriginalValue;
            var dbAmntChange = dbDeckCard.Amount - lastReadAmnt;

            var availEntry = _context
                .Entry(_availables[dbDeckCard.CardId])
                .Property(ca => ca.Amount);

            availEntry.OriginalValue -= dbAmntChange;
        }
        else
        {
            localDeckCard.Amount = dbDeckCard.Amount;
        }

        _context.MatchToken(localDeckCard, dbDeckCard);
    }


    private async Task TrackNewCardAsync(IGrouping<string, CardAmount> cardGroup)
    {
        var cardId = cardGroup.Key;

        if (_deckCards.ContainsKey(cardId))
        {
            return;
        }

        var card = await _context.Cards.FindAsync(cardId);

        foreach (var amount in cardGroup)
        {
            // ensure reference in set to tracked entity
            amount.Card = card;
            amount.Location = _deck;
        }

        var amntGroup = InitGroup(cardGroup);

        if (_context.Entry(amntGroup.Applied).State == EntityState.Detached)
        {
            _context.Attach(amntGroup.Applied);
        }

        if (amntGroup.Request != null)
        {
            _context.Attach(amntGroup.Request);
        }

        _deckCards.Add(cardId, amntGroup);
    }



    private async Task UpdateAvailableAsync()
    {
        var updatedAvails = await _context.Amounts
            .Where(ca => ca.Location.OwnerId == default)
            // TODO: change return location
            // TODO: group amounts by cards
            // .GroupBy(ca => ca.CardId)
            .AsNoTracking()
            .ToListAsync();

        foreach(var dbAvail in updatedAvails)
        {
            dbAvail.Card = await _context.Cards.FindAsync(dbAvail.CardId);
            AddOrMergeAvailable(dbAvail);
        }
    }


    private void AddOrMergeAvailable(CardAmount dbAvailable)
    {
        if (_availables.TryGetValue(dbAvailable.CardId, out var localAvailable))
        {
            var localAmnt = _context.Entry(localAvailable).Property(ca => ca.Amount);
            var localAvailTaken = localAmnt.CurrentValue - localAmnt.OriginalValue;

            localAvailable.Amount = dbAvailable.Amount + localAvailTaken;

            _context.MatchToken(localAvailable, dbAvailable);
            return;
        }

        var availCard = dbAvailable.Card;

        if (_dbCards.TryGetValue(availCard.Name, out var nameGroup))
        {
            nameGroup.Add(availCard);
        }
        else
        {
            _dbCards.Add(availCard.Name, new List<Card>{ availCard });
        }

        _availables.Add(dbAvailable.CardId, dbAvailable);
        _context.Attach(dbAvailable);
    }


}