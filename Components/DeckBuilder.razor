@using MTGViewer.Data

@namespace MTGViewer.Components

@inject NavigationManager NavigationManager
@inject IDbContextFactory<MTGCardContext> DbFactory
@inject ILogger<DeckBuilder> Logger



@code {

    [Parameter]
    public Location Deck { get; set; }

    private IReadOnlyList<Data.Card> dbCards;
    private IDictionary<string, CardAmount> deckCards;
    private IDictionary<string, CardAmount> available;
    private IDictionary<string, int> updateCounts = new Dictionary<string, int>();


    protected override async Task OnInitializedAsync()
    {
        if (Deck.Owner == null)
        {
            Logger.LogError("the given deck has no owner");
        }

        deckCards = Deck.Cards.ToDictionary(c => c.Card.Id, c => c);

        await FetchCardsAsync();
    }

    private async Task FetchCardsAsync()
    {
        using var context = DbFactory.CreateDbContext();

        dbCards = await context.Cards
            .Include(c => c.Colors)
            .Include(c => c.Amounts)
            .ThenInclude(a => a.Location)
            .AsNoTracking()
            .ToListAsync();

        available = dbCards.ToDictionary(
            c => c.Id,
            c => c.Amounts.Single(ca => ca.Location == null));
    }


    private void AddCardToDeck(Card card)
    {
        if (!available.TryGetValue(card.Id, out var availAmnt))
        {
            Logger.LogError($"card {card.Id} is not a listed avaliable card");
            return;
        }

        if (availAmnt.Amount == 0)
        {
            Logger.LogError($"there are no more available {card.Id} cards to add");
            // could maybe handle this "overdraft" error differently
            return;
        }

        availAmnt.Amount -= 1;

        if (!deckCards.TryGetValue(card.Id, out var deckAmnt))
        {
            deckCards.Add(card.Id, DeckAmount(card));
        }
        else {
            deckAmnt.Amount += 1;
        }

        UpdateCardCount(card, 1);
    }

    private void RemoveCardFromDeck(Card card)
    {
        if (!available.TryGetValue(card.Id, out var availAmnt))
        {
            Logger.LogError($"card {card.Id} does exist in available set");
            return;
        }

        if (!deckCards.TryGetValue(card.Id, out var deckAmnt))
        {
            Logger.LogError($"card {card.Id} is not in the deck");
            return;
        }

        if (deckAmnt.Amount == 0)
        {
            Logger.LogError($"there are no more of {card.Id} to remove");
            return;
        }

        availAmnt.Amount += 1;

        deckAmnt.Amount -= 1;

        UpdateCardCount(card, -1);
    }

    private CardAmount DeckAmount(Card card) =>
        new CardAmount {
            Card = card,
            Amount = 1,
            Location = Deck,
            @* IsRequest = true *@
            // not sure when to set request
        };

    private void UpdateCardCount(Card card, int mod)
    {
        if (!updateCounts.TryGetValue(card.Id, out var count))
        {
            count = 0;
        }
        updateCounts[card.Id] = count + mod;
    }

    private async Task CommitChanges()
    {
        using var context = DbFactory.CreateDbContext();

        context.Attach(Deck).State = EntityState.Modified;

        var validUpdates = updateCounts
            .Where(p => p.Value > 0)
            .Select(p => p.Key);

        foreach(var id in validUpdates)
        {
            context.Attach(available[id]);
            var deckTrack = context.Attach(deckCards[id]);

            if (deckTrack.State == EntityState.Unchanged)
            {
                deckTrack.State = EntityState.Modified;
            }
        }

        try {
            await context.SaveChangesAsync();

            NavigationManager.NavigateTo("Cards");
        }
        catch(DbUpdateConcurrencyException)
        {
            Logger.LogError("issue with saving changes");

            // TODO: provide suggestions on how to resolve errors
        }

    }

}