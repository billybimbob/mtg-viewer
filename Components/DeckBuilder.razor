@using MTGViewer.Data
@using MTGViewer.Areas.Identity.Data

@namespace MTGViewer.Components
@implements IDisposable

@inject NavigationManager NavigationManager
@inject IDbContextFactory<MTGCardContext> DbFactory
@inject ILogger<DeckBuilder> Logger


<h1>Deck Builder</h1>

<button title="Save Deck"
        type="button"
        class="btn btn-secondary"
        @onclick="CommitChanges">
    Save Changes
</button>

<h2>Available Cards</h2>

<table class="table">
    <thead>
        <tr>
            <th>Card Name</th>
            <th>Mana Cost</th>
            <th>Set</th>
            <th>Rarity</th>
            <th>Amount Available</th>
            <th></th>
        </tr>
    </thead>

    <tbody>
        @foreach (var card in dbCards)
        {
            var available = availables[card.Id].Amount;
            <tr>
                <td class="fw-bold">@card.Name</td>

                <td>
                    @foreach (var cost in card.GetColorSymbols())
                    {
                        <span class="m-1 ms ms-@cost.ToLower() ms-cost"></span>
                    }
                </td>

                <td>@card.SetName</td>
                <td>@card.Rarity</td>
                <td>@available</td>

                <td>
                    <button title="@card.Name Add"
                            type="button"
                            class="btn btn-outline-secondary border-0 rounded"
                            disabled="@(available==0)"
                            @onclick="() => AddCardToDeck(card)">
                        Add Card
                    </button>
                </td>
            </tr>
        }
    </tbody>
</table>


<input @bind="deck.Name" class="form-control form-control-lg border-0"/>

<table class="table mt-2">
    <thead>
        <tr>
            <th>Card Name</th>
            <th>Mana Cost</th>
            <th>Set</th>
            <th>Deck Amount</th>
            <th></th>
        </tr>
    </thead>

    <tbody>
        @foreach (var card in dbCards)
        {
            @if (deckCards.TryGetValue(card.Id, out var inDeck)
                && inDeck.Amount > 0)
            {
                <tr>
                    <td class="fw-bold">@card.Name</td>

                    <td>
                        @foreach (var cost in card.GetColorSymbols())
                        {
                            <span class="m-1 ms ms-@cost.ToLower() ms-cost"></span>
                        }
                    </td>

                    <td>@card.SetName</td>
                    <td>@inDeck.Amount</td>

                    <td>
                        <button title="@card.Name Remove"
                                type="button"
                                class="btn btn-outline-secondary border-0 rounded"
                                @onclick="() => RemoveCardFromDeck(card)">
                            Remove Card
                        </button>
                    </td>
                </tr>
            }
        }
    </tbody>
</table>


@code {

    [Parameter]
    public CardUser User { get; set; }

    [Parameter]
    public int DeckId { get; set; } = default;


    private MTGCardContext context;
    private Location deck;
    private IReadOnlyList<Data.Card> dbCards;

    private IDictionary<string, CardAmount> deckCards;
    private IDictionary<string, CardAmount> availables;
    private IDictionary<string, int> updateCounts;


    protected override async Task OnInitializedAsync()
    {
        context = DbFactory.CreateDbContext();

        dbCards = await context.Cards
            .Include(c => c.Colors)
            .Include(c => c.Amounts)
            .ThenInclude(a => a.Location)
            .OrderBy(c => c.Name)
            .ToListAsync();
    }


    protected override async Task OnParametersSetAsync()
    {
        deck = await GetDeck();

        deckCards = deck.Cards.ToDictionary(c => c.Card.Id);

        availables = dbCards.ToDictionary(
            c => c.Id,
            c => c.Amounts.Single(ca => ca.Location == null));

        updateCounts = new Dictionary<string, int>();
    }


    private async Task<Location> GetDeck()
    {
        if (DeckId == default)
        {
            var userDeckCount = await context.Locations
                .Where(l => l.Owner == User)
                .CountAsync();

            return new Location
            {
                Name = $"Deck #{userDeckCount + 1}",
                Owner = User
            };
        }
        else
        {
            return await context.Locations
                .Include(l => l.Cards)
                .ThenInclude(a => a.Card)
                .SingleAsync(l => l.Id == DeckId);
        }
    }

    private void AddCardToDeck(Card card)
    {
        if (!availables.TryGetValue(card.Id, out var availAmnt))
        {
            Logger.LogError($"card {card.Id} is not a listed avaliable card");
            return;
        }

        if (availAmnt.Amount == 0)
        {
            Logger.LogError($"there are no more available {card.Id} cards to add");
            // could maybe handle this "overdraft" error differently
            return;
        }

        availAmnt.Amount -= 1;

        if (deckCards.TryGetValue(card.Id, out var deckAmnt))
        {
            deckAmnt.Amount += 1;
        }
        else
        {
            var newAmnt = NewDeckAmount(card);
            card.Amounts.Add(newAmnt);
            deckCards.Add(card.Id, newAmnt);
        }

        UpdateCardCount(card, 1);
    }


    private void RemoveCardFromDeck(Card card)
    {
        if (!availables.TryGetValue(card.Id, out var availAmnt))
        {
            Logger.LogError($"card {card.Id} does exist in available set");
            return;
        }

        if (!deckCards.TryGetValue(card.Id, out var deckAmnt))
        {
            Logger.LogError($"card {card.Id} is not in the deck");
            return;
        }

        if (deckAmnt.Amount == 0)
        {
            Logger.LogError($"there are no more of {card.Id} to remove");
            return;
        }

        availAmnt.Amount += 1;

        deckAmnt.Amount -= 1;

        UpdateCardCount(card, -1);
    }


    private CardAmount NewDeckAmount(Card card) =>
        new CardAmount {
            Card = card,
            Amount = 1,
            Location = deck,
            // IsRequest = true
            // not sure when to set request
        };


    private void UpdateCardCount(Card card, int mod)
    {
        if (!updateCounts.TryGetValue(card.Id, out var count))
        {
            count = 0;
        }

        updateCounts[card.Id] = count + mod;
    }


    private async Task CommitChanges()
    {
        foreach(var cardAmnt in deck.Cards)
        {
            if (cardAmnt.Amount == 0)
            {
                cardAmnt.Card.Amounts.Remove(cardAmnt);
            }
        }

        try {
            await context.SaveChangesAsync();

            Logger.LogInformation($"trying to nav to index, at {NavigationManager.BaseUri}");
            NavigationManager.NavigateTo("Cards/Index");

            updateCounts.Clear();
        }
        catch(DbUpdateConcurrencyException)
        {
            Logger.LogError("issue with saving changes");

            // TODO: provide suggestions on how to resolve errors
        }

    }

    public void Dispose()
    {
        context.Dispose();
    }

}